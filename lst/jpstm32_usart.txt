; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jpstm32_usart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\jpstm32_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\core -I.\devices -I.\app -I.\boot -I.\app\RES\Num -I.\app\RES\Pic -I"D:\Program Files\Keil\ARM\RV31\INC" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\obj\jpstm32_usart.crf core\jpstm32_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;27     //定义_sys_exit()以避免使用半主机模式    
;;;28     _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;29     { 
;;;30     	x = x; 
000002  bf00              NOP      
;;;31     } 
000004  4770              BX       lr
;;;32     //重定义fputc函数 
                          ENDP

                  fputc PROC
;;;33     int fputc(int ch, FILE *f)
000006  bf00              NOP      
                  |L1.8|
;;;34     {      
;;;35     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000008  4a7c              LDR      r2,|L1.508|
00000a  8812              LDRH     r2,[r2,#0]
00000c  f0120f40          TST      r2,#0x40
000010  d0fa              BEQ      |L1.8|
;;;36     	USART1->DR = (u8) ch;      
000012  b2c2              UXTB     r2,r0
000014  4b79              LDR      r3,|L1.508|
000016  1d1b              ADDS     r3,r3,#4
000018  801a              STRH     r2,[r3,#0]
;;;37     	return ch;
;;;38     }
00001a  4770              BX       lr
;;;39     #endif 
                          ENDP

                  USART1_IRQHandler PROC
;;;42      
;;;43     void USART1_IRQHandler(void)
00001c  4977              LDR      r1,|L1.508|
;;;44     {
;;;45     	u8 res;
;;;46     	#ifdef OS_CRITICAL_METHOD
;;;47     		OSIntEnter();
;;;48     	#endif
;;;49     	if(USART1->SR & (1<<5))/*判断是否接受到数据*/
00001e  8809              LDRH     r1,[r1,#0]
000020  f0110f20          TST      r1,#0x20
000024  d032              BEQ      |L1.140|
;;;50     	{	
;;;51     		res = USART1->DR;
000026  4975              LDR      r1,|L1.508|
000028  1d09              ADDS     r1,r1,#4
00002a  8809              LDRH     r1,[r1,#0]
00002c  b2c8              UXTB     r0,r1
;;;52     		if(!(usart1.rx_stat&RX_BUF_F))
00002e  4974              LDR      r1,|L1.512|
000030  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
000034  f0110f01          TST      r1,#1
000038  d128              BNE      |L1.140|
;;;53     		{
;;;54     				usart1.rx_buf[usart1.rx_size] = res;
00003a  b241              SXTB     r1,r0
00003c  4a70              LDR      r2,|L1.512|
00003e  f8b22102          LDRH     r2,[r2,#0x102]  ; usart1
000042  4b6f              LDR      r3,|L1.512|
000044  5499              STRB     r1,[r3,r2]
;;;55     				usart1.rx_size++;
000046  4619              MOV      r1,r3
000048  f8b11102          LDRH     r1,[r1,#0x102]  ; usart1
00004c  1c49              ADDS     r1,r1,#1
00004e  461a              MOV      r2,r3
000050  f8a21102          STRH     r1,[r2,#0x102]
;;;56     				usart1.rx_size = usart1.rx_size&RX_MASK;
000054  4611              MOV      r1,r2
000056  f8911102          LDRB     r1,[r1,#0x102]  ; usart1
00005a  f8a21102          STRH     r1,[r2,#0x102]
;;;57     				if(usart1.rx_size == usart1.rx_seek)
00005e  4611              MOV      r1,r2
000060  f8b11102          LDRH     r1,[r1,#0x102]  ; usart1
000064  f8b22100          LDRH     r2,[r2,#0x100]  ; usart1
000068  4291              CMP      r1,r2
00006a  d107              BNE      |L1.124|
;;;58     				{
;;;59     					usart1.rx_stat |= RX_BUF_F;
00006c  4619              MOV      r1,r3
00006e  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
000072  f0410101          ORR      r1,r1,#1
000076  461a              MOV      r2,r3
000078  f8821104          STRB     r1,[r2,#0x104]
                  |L1.124|
;;;60     				}
;;;61     				usart1.rx_stat &= ~RX_BUF_E;
00007c  4960              LDR      r1,|L1.512|
00007e  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
000082  f0210102          BIC      r1,r1,#2
000086  4a5e              LDR      r2,|L1.512|
000088  f8821104          STRB     r1,[r2,#0x104]
                  |L1.140|
;;;62     		}
;;;63     	}
;;;64     	//printf("%s\r\n", usart1.rx_buf);
;;;65     	#ifdef OS_CRITICAL_METHOD
;;;66     		OSIntExit();
;;;67     	#endif
;;;68     } 
00008c  4770              BX       lr
;;;69     
                          ENDP

                  usart1_getc PROC
;;;70     //获取一个字节的数据
;;;71     s8	usart1_getc(void)
00008e  495c              LDR      r1,|L1.512|
;;;72     {
;;;73     	s8	res;
;;;74     	if(!(usart1.rx_stat&RX_BUF_E))
000090  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
000094  f0110f02          TST      r1,#2
000098  d127              BNE      |L1.234|
;;;75     	{
;;;76     		res = usart1.rx_buf[usart1.rx_seek];
00009a  4959              LDR      r1,|L1.512|
00009c  f8b11100          LDRH     r1,[r1,#0x100]  ; usart1
0000a0  4a57              LDR      r2,|L1.512|
0000a2  5650              LDRSB    r0,[r2,r1]
;;;77     		usart1.rx_seek++;
0000a4  4611              MOV      r1,r2
0000a6  f8b11100          LDRH     r1,[r1,#0x100]  ; usart1
0000aa  1c49              ADDS     r1,r1,#1
0000ac  f8a21100          STRH     r1,[r2,#0x100]
;;;78     		usart1.rx_seek = usart1.rx_seek&RX_MASK;
0000b0  4611              MOV      r1,r2
0000b2  f8911100          LDRB     r1,[r1,#0x100]  ; usart1
0000b6  f8a21100          STRH     r1,[r2,#0x100]
;;;79     		if(usart1.rx_size == usart1.rx_seek)
0000ba  4611              MOV      r1,r2
0000bc  f8b11102          LDRH     r1,[r1,#0x102]  ; usart1
0000c0  f8b22100          LDRH     r2,[r2,#0x100]  ; usart1
0000c4  4291              CMP      r1,r2
0000c6  d107              BNE      |L1.216|
;;;80     		{
;;;81     			usart1.rx_stat |= RX_BUF_E;
0000c8  494d              LDR      r1,|L1.512|
0000ca  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
0000ce  f0410102          ORR      r1,r1,#2
0000d2  4a4b              LDR      r2,|L1.512|
0000d4  f8821104          STRB     r1,[r2,#0x104]
                  |L1.216|
;;;82     		}
;;;83     		usart1.rx_stat &= ~RX_BUF_F;
0000d8  4949              LDR      r1,|L1.512|
0000da  f8911104          LDRB     r1,[r1,#0x104]  ; usart1
0000de  f0210101          BIC      r1,r1,#1
0000e2  4a47              LDR      r2,|L1.512|
0000e4  f8821104          STRB     r1,[r2,#0x104]
0000e8  e001              B        |L1.238|
                  |L1.234|
;;;84     	}
;;;85     	else 
;;;86     	{
;;;87     		res = -1;
0000ea  f04f30ff          MOV      r0,#0xffffffff
                  |L1.238|
;;;88     	}
;;;89     	return res;
;;;90     }
0000ee  4770              BX       lr
;;;91     
                          ENDP

                  usart1_gets PROC
;;;92     //获取一个定长的字符串
;;;93     u8 usart1_gets(s8* buf, u16 len)
0000f0  b570              PUSH     {r4-r6,lr}
;;;94     {
0000f2  4604              MOV      r4,r0
0000f4  460d              MOV      r5,r1
;;;95     	u16 i = 0;
0000f6  2600              MOVS     r6,#0
;;;96     	s8 res;
;;;97     	while(len>1)
0000f8  e009              B        |L1.270|
                  |L1.250|
;;;98     	{
;;;99     		res = usart1_getc();
0000fa  f7fffffe          BL       usart1_getc
0000fe  4603              MOV      r3,r0
;;;100    		if(res!=-1)
000100  1c58              ADDS     r0,r3,#1
000102  d004              BEQ      |L1.270|
;;;101    		{
;;;102    			buf[i] = res;
000104  55a3              STRB     r3,[r4,r6]
;;;103    			len--;
000106  1e68              SUBS     r0,r5,#1
000108  b285              UXTH     r5,r0
;;;104    			i++;
00010a  1c70              ADDS     r0,r6,#1
00010c  b286              UXTH     r6,r0
                  |L1.270|
00010e  2d01              CMP      r5,#1                 ;97
000110  dcf3              BGT      |L1.250|
;;;105    		}
;;;106    	}
;;;107    	buf[i] = 0;
000112  2000              MOVS     r0,#0
000114  55a0              STRB     r0,[r4,r6]
;;;108    	return 0;
;;;109    }
000116  bd70              POP      {r4-r6,pc}
;;;110    
                          ENDP

                  usart1_init PROC
;;;114    //bound:波特率
;;;115    void usart1_init(u32 pclk2,u32 bound)
000118  e92d5ff0          PUSH     {r4-r12,lr}
;;;116    {
00011c  4605              MOV      r5,r0
00011e  460e              MOV      r6,r1
;;;117    	float temp;
;;;118    	u16 mantissa,fraction;
;;;119    	temp = (float)(pclk2 * 1000000)/(bound * 16);
000120  0130              LSLS     r0,r6,#4
000122  f7fffffe          BL       __aeabi_ui2f
000126  4681              MOV      r9,r0
000128  4936              LDR      r1,|L1.516|
00012a  fb05f001          MUL      r0,r5,r1
00012e  f7fffffe          BL       __aeabi_ui2f
000132  4682              MOV      r10,r0
000134  4649              MOV      r1,r9
000136  f7fffffe          BL       __aeabi_fdiv
00013a  4607              MOV      r7,r0
;;;120    	mantissa = temp;
00013c  4638              MOV      r0,r7
00013e  f7fffffe          BL       __aeabi_f2uiz
000142  b284              UXTH     r4,r0
;;;121    	fraction = (temp - mantissa)*16;
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       __aeabi_ui2f
00014a  4683              MOV      r11,r0
00014c  4639              MOV      r1,r7
00014e  f7fffffe          BL       __aeabi_frsub
000152  4682              MOV      r10,r0
000154  f04f4183          MOV      r1,#0x41800000
000158  f7fffffe          BL       __aeabi_fmul
00015c  4681              MOV      r9,r0
00015e  f7fffffe          BL       __aeabi_f2uiz
000162  4680              MOV      r8,r0
;;;122    	mantissa = (mantissa<<4) + fraction;
000164  eb081004          ADD      r0,r8,r4,LSL #4
000168  b284              UXTH     r4,r0
;;;123    	//PORTC 时钟时能
;;;124    	_BD(RCC->APB2ENR, 2) = 1;
00016a  2001              MOVS     r0,#1
00016c  4926              LDR      r1,|L1.520|
00016e  6008              STR      r0,[r1,#0]
;;;125    	//USART1 时钟时能
;;;126    	_BD(RCC->APB2ENR, 14) = 1;
000170  4926              LDR      r1,|L1.524|
000172  f8c10338          STR      r0,[r1,#0x338]
;;;127    	GPIOA->CRH &= 0xfffff00f;
000176  4826              LDR      r0,|L1.528|
000178  6800              LDR      r0,[r0,#0]
00017a  f420607f          BIC      r0,r0,#0xff0
00017e  4924              LDR      r1,|L1.528|
000180  6008              STR      r0,[r1,#0]
;;;128    	GPIOA->CRH |= 0xfffff8Bf;
000182  4608              MOV      r0,r1
000184  6800              LDR      r0,[r0,#0]
000186  f46060e8          ORN      r0,r0,#0x740
00018a  6008              STR      r0,[r1,#0]
;;;129    	//复位USART1, 先置1再清0
;;;130    	_BD(RCC->APB2RSTR, 14) = 1;
00018c  f04f0001          MOV      r0,#1
000190  4920              LDR      r1,|L1.532|
000192  6008              STR      r0,[r1,#0]
;;;131    	_BD(RCC->APB2RSTR, 14) = 0;
000194  f04f0000          MOV      r0,#0
000198  491c              LDR      r1,|L1.524|
00019a  f8c101b8          STR      r0,[r1,#0x1b8]
;;;132    	
;;;133    	USART1->BRR = mantissa;
00019e  481e              LDR      r0,|L1.536|
0001a0  8004              STRH     r4,[r0,#0]
;;;134    	USART1->CR1 |= 0x200C;
0001a2  f1000004          ADD      r0,r0,#4
0001a6  8800              LDRH     r0,[r0,#0]
0001a8  f242010c          MOV      r1,#0x200c
0001ac  ea400001          ORR      r0,r0,r1
0001b0  491a              LDR      r1,|L1.540|
0001b2  8008              STRH     r0,[r1,#0]
;;;135    	
;;;136    #if EN_USART1_RX
;;;137    	//接收缓冲区初始化
;;;138    	usart1.rx_seek = 0;
0001b4  f04f0000          MOV      r0,#0
0001b8  4911              LDR      r1,|L1.512|
0001ba  f8a10100          STRH     r0,[r1,#0x100]
;;;139    	usart1.rx_size = 0;
0001be  f8a10102          STRH     r0,[r1,#0x102]
;;;140    	usart1.rx_stat |= RX_BUF_E;
0001c2  4608              MOV      r0,r1
0001c4  f8900104          LDRB     r0,[r0,#0x104]  ; usart1
0001c8  f0400002          ORR      r0,r0,#2
0001cc  f8810104          STRB     r0,[r1,#0x104]
;;;141    	
;;;142    	//USART1接收终端处理
;;;143    	_BD(USART1->CR1, 8) = 1;		//奇偶校验终中断开启
0001d0  f04f0001          MOV      r0,#1
0001d4  4912              LDR      r1,|L1.544|
0001d6  6008              STR      r0,[r1,#0]
;;;144    	_BD(USART1->CR1, 5) = 1;		//很重要，RXNIE，当UASRT_SR的RXNE(有数据了，即读数据寄存器非空),将发生对应中断
0001d8  4912              LDR      r1,|L1.548|
0001da  f8c10194          STR      r0,[r1,#0x194]
;;;145    	register_nvic(0, 10, 4, USART1_IRQChannel);
0001de  f04f0325          MOV      r3,#0x25
0001e2  f04f0204          MOV      r2,#4
0001e6  f04f010a          MOV      r1,#0xa
0001ea  f04f0000          MOV      r0,#0
0001ee  f7fffffe          BL       register_nvic
;;;146    	nvic_set_enable(USART1_IRQChannel);
0001f2  2025              MOVS     r0,#0x25
0001f4  f7fffffe          BL       nvic_set_enable
;;;147    #endif
;;;148    }
0001f8  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

                  |L1.508|
                          DCD      0x40013800
                  |L1.512|
                          DCD      usart1
                  |L1.516|
                          DCD      0x000f4240
                  |L1.520|
                          DCD      0x42420308
                  |L1.524|
                          DCD      0x42420000
                  |L1.528|
                          DCD      0x40010804
                  |L1.532|
                          DCD      0x424201b8
                  |L1.536|
                          DCD      0x40013808
                  |L1.540|
                          DCD      0x4001380c
                  |L1.544|
                          DCD      0x422701a0
                  |L1.548|
                          DCD      0x42270000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  usart1
                          %        262

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
