L 1 "devices\jpstm32_lcd.c"
N#include "jpstm32_lcd.h"
L 1 "devices\jpstm32_lcd.h" 1
N/* ****************************************************
N * 描    述：本程序用于定义TFT-LCD驱动相关的操作
N * 作    者：Duke An
N * 时    间：2014年8月
N * 版    权：杰普软件科技有限公司版权所有，
N *			 转载请注明出处，侵权必究！
N * 更新说明：
N * 编码规范：宏定义--大写，单词之间用下划线分割
N *			 结构--首字母大写，驼峰命名
N *			 枚举--首字母大写，驼峰命名
N *			 函数--首字母小写，驼峰命名
N *			 局部变量--小写，单词之间用下划线分割
N *			 全局变量--首字母大写，单词之间用下划线分割
N * ***************************************************/
N#ifndef __TFTLCD_H__
N#define __TFTLCD_H__
N
N/* ****************************************************
N * JPIOT-STM32-V1开发板采用3.5英寸ILI9486液晶，支持最大
N * 分辨率为480*320。为提高数据访问速度，特别采用16位并行
N * 接口与CPU进行连接，此液晶屏采用的80并口(intel 提出的
N * 一种并口通信协议)主要信号线及连接方式如下：
N *
N * LCD_CS：			TFT-LCD片选信号
N * LCD_WR：			向TFT-LCD写入数据，低电平有效
N * LCD_RD：			从TFT-LCD读取数据，低电平有效
N * LCD_DB[15:0]：	16位双向数据线
N * LCD_RST：		复位	
N * LCD_RS：			命令/数据标志(0-命令操作;1-数据操作)
N *
N * JPIOT-STM32-V1开发板LCD硬件连接方式：
N * ________________
N *           RESET |---LCD_RESET
N *   PG12/FSMC_NE4 |---LCD_CS
N *    PG0/FSMC_A10 |---LCD_RS
N *    PD4/FSMC_NOE |---LCD_RD
N *    PD5/FSMC_NWE |---LCD_WR
N *             PB0 |---LCD_BL		//背光
N *    PD14/FSMC_D0 |---LCD_DB1
N *    PD15/FSMC_D1 |---LCD_DB2
N *     PD0/FSMC_D2 |---LCD_DB3
N *     PD1/FSMC_D3 |---LCD_DB4
N *	   PE7/FSMC_D4 |---LCD_DB5
N *	   PE8/FSMC_D5 |---LCD_DB6
N *	   PE9/FSMC_D6 |---LCD_DB7
N *	  PE10/FSMC_D7 |---LCD_DB8
N *	  PE11/FSMC_D8 |---LCD_DB10
N *	  PE12/FSMC_D9 |---LCD_DB11
N *   PE13/FSMC_D10 |---LCD_DB12
N *   PE14/FSMC_D11 |---LCD_DB13
N *   PE15/FSMC_D12 |---LCD_DB14
N *    PD8/FSMC_D13 |---LCD_DB15
N *    PD9/FSMC_D14 |---LCD_DB16
N *   PD10/FSMC_D15 |---LCD_DB17
N * ________________|
N * ***************************************************/
N
N#include "jpstm32_gpio.h"
L 1 ".\core\jpstm32_gpio.h" 1
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * File name: jpstm32_gpio.h
N * Author: Duke An
N * Version: 0.1
N * Date: 2014-06-17
N * Description: 系统通用I/O接口定义
N * Copyright @ 2013 by Briup Technology,Inc. All rights Reserved.
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N
N#ifndef __JPSTM32_GPIO_H__
N#define __JPSTM32_GPIO_H__
N
N#include "jpstm32_common.h"
L 1 ".\core\jpstm32_common.h" 1
N/*************************************************************
N * File name: jpstm32_common.h
N * Author: Duke An
N * Version: 0.1
N * Date: 20140617
N * Description: 系统通用头文件，用于定义通用数据结构等
N * Copyright @ 2013 by Briup Technology,Inc. All rights Reserved.
N *************************************************************/
N#ifndef __JPSTM32_COMMON_H__
N#define __JPSTM32_COMMON_H__
N
N#include <stm32f10x_map.h>
L 1 ".\core\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 ".\core\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : Library configuration file.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 ".\core\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 22 ".\core\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert_param" macro in the firmware library code (see "Exported macro"
N   section below) */
N/* #define DEBUG    1*/
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N#define _ADC3
N
N/************************************* BKP ************************************/
N#define _BKP 
N
N/************************************* CAN ************************************/
N#define _CAN
N
N/************************************* CRC ************************************/
N#define _CRC
N
N/************************************* DAC ************************************/
N#define _DAC
N
N/************************************* DBGMCU *********************************/
N#define _DBGMCU
N
N/************************************* DMA ************************************/
N#define _DMA
N#define _DMA1_Channel1
N#define _DMA1_Channel2
N#define _DMA1_Channel3
N#define _DMA1_Channel4
N#define _DMA1_Channel5
N#define _DMA1_Channel6
N#define _DMA1_Channel7
N#define _DMA2_Channel1
N#define _DMA2_Channel2
N#define _DMA2_Channel3
N#define _DMA2_Channel4
N#define _DMA2_Channel5
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N#define _FLASH_PROG
N
N/************************************* FSMC ***********************************/
N#define _FSMC
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _GPIOF
N#define _GPIOG
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N#define _I2C2
N
N/************************************* IWDG ***********************************/
N#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SDIO ***********************************/
N#define _SDIO
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N#define _SPI3
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM1
N#define _TIM2
N#define _TIM3
N#define _TIM4
N#define _TIM5
N#define _TIM6
N#define _TIM7
N#define _TIM8
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N#define _UART4
N#define _UART5
N
N/************************************* WWDG ***********************************/
N#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert_param
S* Description    : The assert_param macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode. 
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed. 
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/ 
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 27 ".\core\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 ".\core\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 29 ".\core\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;
N  vu32 CR1;
N  vu32 CR2;
N  vu32 SMPR1;
N  vu32 SMPR2;
N  vu32 JOFR1;
N  vu32 JOFR2;
N  vu32 JOFR3;
N  vu32 JOFR4;
N  vu32 HTR;
N  vu32 LTR;
N  vu32 SQR1;
N  vu32 SQR2;
N  vu32 SQR3;
N  vu32 JSQR;
N  vu32 JDR1;
N  vu32 JDR2;
N  vu32 JDR3;
N  vu32 JDR4;
N  vu32 DR;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;
N  u16  RESERVED1;
N  vu16 DR2;
N  u16  RESERVED2;
N  vu16 DR3;
N  u16  RESERVED3;
N  vu16 DR4;
N  u16  RESERVED4;
N  vu16 DR5;
N  u16  RESERVED5;
N  vu16 DR6;
N  u16  RESERVED6;
N  vu16 DR7;
N  u16  RESERVED7;
N  vu16 DR8;
N  u16  RESERVED8;
N  vu16 DR9;
N  u16  RESERVED9;
N  vu16 DR10;
N  u16  RESERVED10; 
N  vu16 RTCCR;
N  u16  RESERVED11;
N  vu16 CR;
N  u16  RESERVED12;
N  vu16 CSR;
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;
N  vu32 CNDTR;
N  vu32 CPAR;
N  vu32 CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;
N  vu32 IFCR;
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;
N  vu32 EMR;
N  vu32 RTSR;
N  vu32 FTSR;
N  vu32 SWIER;
N  vu32 PR;
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;
N  vu32 KEYR;
N  vu32 OPTKEYR;
N  vu32 SR;
N  vu32 CR;
N  vu32 AR;
N  vu32 RESERVED;
N  vu32 OBR;
N  vu32 WRPR;
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;
N  vu16 USER;
N  vu16 Data0;
N  vu16 Data1;
N  vu16 WRP0;
N  vu16 WRP1;
N  vu16 WRP2;
N  vu16 WRP3;
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;
N  vu32 CRH;
N  vu32 IDR;
N  vu32 ODR;
N  vu32 BSRR;
N  vu32 BRR;
N  vu32 LCKR;
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;
N  vu32 MAPR;
N  vu32 EXTICR[4];
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;
N  vu32 PR;
N  vu32 RLR;
N  vu32 SR;
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];
N  u32  RESERVED0[30];
N  vu32 ICER[2];
N  u32  RSERVED1[30];
N  vu32 ISPR[2];
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;
N  vu32 ICSR;
N  vu32 VTOR;
N  vu32 AIRCR;
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFGR;
N  vu32 CIR;
N  vu32 APB2RSTR;
N  vu32 APB1RSTR;
N  vu32 AHBENR;
N  vu32 APB2ENR;
N  vu32 APB1ENR;
N  vu32 BDCR;
N  vu32 CSR;
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;
N  u16  RESERVED0;
N  vu16 CRL;
N  u16  RESERVED1;
N  vu16 PRLH;
N  u16  RESERVED2;
N  vu16 PRLL;
N  u16  RESERVED3;
N  vu16 DIVH;
N  u16  RESERVED4;
N  vu16 DIVL;
N  u16  RESERVED5;
N  vu16 CNTH;
N  u16  RESERVED6;
N  vu16 CNTL;
N  u16  RESERVED7;
N  vu16 ALRH;
N  u16  RESERVED8;
N  vu16 ALRL;
N  u16  RESERVED9;
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SR;
N  u16  RESERVED2;
N  vu16 DR;
N  u16  RESERVED3;
N  vu16 CRCPR;
N  u16  RESERVED4;
N  vu16 RXCRCR;
N  u16  RESERVED5;
N  vu16 TXCRCR;
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;
N  vu32 LOAD;
N  vu32 VAL;
N  vuc32 CALIB;
N} SysTick_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SMCR;
N  u16  RESERVED2;
N  vu16 DIER;
N  u16  RESERVED3;
N  vu16 SR;
N  u16  RESERVED4;
N  vu16 EGR;
N  u16  RESERVED5;
N  vu16 CCMR1;
N  u16  RESERVED6;
N  vu16 CCMR2;
N  u16  RESERVED7;
N  vu16 CCER;
N  u16  RESERVED8;
N  vu16 CNT;
N  u16  RESERVED9;
N  vu16 PSC;
N  u16  RESERVED10;
N  vu16 ARR;
N  u16  RESERVED11;
N  vu16 RCR;
N  u16  RESERVED12;
N  vu16 CCR1;
N  u16  RESERVED13;
N  vu16 CCR2;
N  u16  RESERVED14;
N  vu16 CCR3;
N  u16  RESERVED15;
N  vu16 CCR4;
N  u16  RESERVED16;
N  vu16 BDTR;
N  u16  RESERVED17;
N  vu16 DCR;
N  u16  RESERVED18;
N  vu16 DMAR;
N  u16  RESERVED19;
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;
N  u16  RESERVED0;
N  vu16 DR;
N  u16  RESERVED1;
N  vu16 BRR;
N  u16  RESERVED2;
N  vu16 CR1;
N  u16  RESERVED3;
N  vu16 CR2;
N  u16  RESERVED4;
N  vu16 CR3;
N  u16  RESERVED5;
N  vu16 GTPR;
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFR;
N  vu32 SR;
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
N  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
N  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
N  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
N  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
N  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
N  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
N  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
N  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
N  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
N  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
N  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
N  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
N  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
N  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
N  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
N  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
N  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
N  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
N  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
N  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
N  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
N  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
N  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
N  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
N  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
N  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
N  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
N  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
N  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
N  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
N  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
N  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
N  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 13 ".\core\jpstm32_common.h" 2
N#include <stm32f10x_type.h>
N#include <stm32f10x_nvic.h>
L 1 ".\core\stm32f10x_nvic.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_nvic.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      NVIC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_NVIC_H
N#define __STM32F10x_NVIC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* NVIC Init Structure definition */
Ntypedef struct
N{
N  u8 NVIC_IRQChannel;
N  u8 NVIC_IRQChannelPreemptionPriority;
N  u8 NVIC_IRQChannelSubPriority;
N  FunctionalState NVIC_IRQChannelCmd;
N} NVIC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* IRQ Channels --------------------------------------------------------------*/
N#define WWDG_IRQChannel              ((u8)0x00)  /* Window WatchDog Interrupt */
N#define PVD_IRQChannel               ((u8)0x01)  /* PVD through EXTI Line detection Interrupt */
N#define TAMPER_IRQChannel            ((u8)0x02)  /* Tamper Interrupt */
N#define RTC_IRQChannel               ((u8)0x03)  /* RTC global Interrupt */
N#define FLASH_IRQChannel             ((u8)0x04)  /* FLASH global Interrupt */
N#define RCC_IRQChannel               ((u8)0x05)  /* RCC global Interrupt */
N#define EXTI0_IRQChannel             ((u8)0x06)  /* EXTI Line0 Interrupt */
N#define EXTI1_IRQChannel             ((u8)0x07)  /* EXTI Line1 Interrupt */
N#define EXTI2_IRQChannel             ((u8)0x08)  /* EXTI Line2 Interrupt */
N#define EXTI3_IRQChannel             ((u8)0x09)  /* EXTI Line3 Interrupt */
N#define EXTI4_IRQChannel             ((u8)0x0A)  /* EXTI Line4 Interrupt */
N#define DMA1_Channel1_IRQChannel     ((u8)0x0B)  /* DMA1 Channel 1 global Interrupt */
N#define DMA1_Channel2_IRQChannel     ((u8)0x0C)  /* DMA1 Channel 2 global Interrupt */
N#define DMA1_Channel3_IRQChannel     ((u8)0x0D)  /* DMA1 Channel 3 global Interrupt */
N#define DMA1_Channel4_IRQChannel     ((u8)0x0E)  /* DMA1 Channel 4 global Interrupt */
N#define DMA1_Channel5_IRQChannel     ((u8)0x0F)  /* DMA1 Channel 5 global Interrupt */
N#define DMA1_Channel6_IRQChannel     ((u8)0x10)  /* DMA1 Channel 6 global Interrupt */
N#define DMA1_Channel7_IRQChannel     ((u8)0x11)  /* DMA1 Channel 7 global Interrupt */
N#define ADC1_2_IRQChannel            ((u8)0x12)  /* ADC1 et ADC2 global Interrupt */
N#define USB_HP_CAN_TX_IRQChannel     ((u8)0x13)  /* USB High Priority or CAN TX Interrupts */
N#define USB_LP_CAN_RX0_IRQChannel    ((u8)0x14)  /* USB Low Priority or CAN RX0 Interrupts */
N#define CAN_RX1_IRQChannel           ((u8)0x15)  /* CAN RX1 Interrupt */
N#define CAN_SCE_IRQChannel           ((u8)0x16)  /* CAN SCE Interrupt */
N#define EXTI9_5_IRQChannel           ((u8)0x17)  /* External Line[9:5] Interrupts */
N#define TIM1_BRK_IRQChannel          ((u8)0x18)  /* TIM1 Break Interrupt */
N#define TIM1_UP_IRQChannel           ((u8)0x19)  /* TIM1 Update Interrupt */
N#define TIM1_TRG_COM_IRQChannel      ((u8)0x1A)  /* TIM1 Trigger and Commutation Interrupt */
N#define TIM1_CC_IRQChannel           ((u8)0x1B)  /* TIM1 Capture Compare Interrupt */
N#define TIM2_IRQChannel              ((u8)0x1C)  /* TIM2 global Interrupt */
N#define TIM3_IRQChannel              ((u8)0x1D)  /* TIM3 global Interrupt */
N#define TIM4_IRQChannel              ((u8)0x1E)  /* TIM4 global Interrupt */
N#define I2C1_EV_IRQChannel           ((u8)0x1F)  /* I2C1 Event Interrupt */
N#define I2C1_ER_IRQChannel           ((u8)0x20)  /* I2C1 Error Interrupt */
N#define I2C2_EV_IRQChannel           ((u8)0x21)  /* I2C2 Event Interrupt */
N#define I2C2_ER_IRQChannel           ((u8)0x22)  /* I2C2 Error Interrupt */
N#define SPI1_IRQChannel              ((u8)0x23)  /* SPI1 global Interrupt */
N#define SPI2_IRQChannel              ((u8)0x24)  /* SPI2 global Interrupt */
N#define USART1_IRQChannel            ((u8)0x25)  /* USART1 global Interrupt */
N#define USART2_IRQChannel            ((u8)0x26)  /* USART2 global Interrupt */
N#define USART3_IRQChannel            ((u8)0x27)  /* USART3 global Interrupt */
N#define EXTI15_10_IRQChannel         ((u8)0x28)  /* External Line[15:10] Interrupts */
N#define RTCAlarm_IRQChannel          ((u8)0x29)  /* RTC Alarm through EXTI Line Interrupt */
N#define USBWakeUp_IRQChannel         ((u8)0x2A)  /* USB WakeUp from suspend through EXTI Line Interrupt */
N#define TIM8_BRK_IRQChannel          ((u8)0x2B)  /* TIM8 Break Interrupt */
N#define TIM8_UP_IRQChannel           ((u8)0x2C)  /* TIM8 Update Interrupt */
N#define TIM8_TRG_COM_IRQChannel      ((u8)0x2D)  /* TIM8 Trigger and Commutation Interrupt */
N#define TIM8_CC_IRQChannel           ((u8)0x2E)  /* TIM8 Capture Compare Interrupt */
N#define ADC3_IRQChannel              ((u8)0x2F)  /* ADC3 global Interrupt */
N#define FSMC_IRQChannel              ((u8)0x30)  /* FSMC global Interrupt */
N#define SDIO_IRQChannel              ((u8)0x31)  /* SDIO global Interrupt */
N#define TIM5_IRQChannel              ((u8)0x32)  /* TIM5 global Interrupt */
N#define SPI3_IRQChannel              ((u8)0x33)  /* SPI3 global Interrupt */
N#define UART4_IRQChannel             ((u8)0x34)  /* UART4 global Interrupt */
N#define UART5_IRQChannel             ((u8)0x35)  /* UART5 global Interrupt */
N#define TIM6_IRQChannel              ((u8)0x36)  /* TIM6 global Interrupt */
N#define TIM7_IRQChannel              ((u8)0x37)  /* TIM7 global Interrupt */
N#define DMA2_Channel1_IRQChannel     ((u8)0x38)  /* DMA2 Channel 1 global Interrupt */
N#define DMA2_Channel2_IRQChannel     ((u8)0x39)  /* DMA2 Channel 2 global Interrupt */
N#define DMA2_Channel3_IRQChannel     ((u8)0x3A)  /* DMA2 Channel 3 global Interrupt */
N#define DMA2_Channel4_5_IRQChannel   ((u8)0x3B)  /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt */
N
N
N#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) || \
N                                      ((CHANNEL) == PVD_IRQChannel) || \
N                                      ((CHANNEL) == TAMPER_IRQChannel) || \
N                                      ((CHANNEL) == RTC_IRQChannel) || \
N                                      ((CHANNEL) == FLASH_IRQChannel) || \
N                                      ((CHANNEL) == RCC_IRQChannel) || \
N                                      ((CHANNEL) == EXTI0_IRQChannel) || \
N                                      ((CHANNEL) == EXTI1_IRQChannel) || \
N                                      ((CHANNEL) == EXTI2_IRQChannel) || \
N                                      ((CHANNEL) == EXTI3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel5_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel6_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel7_IRQChannel) || \
N                                      ((CHANNEL) == ADC1_2_IRQChannel) || \
N                                      ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) || \
N                                      ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) || \
N                                      ((CHANNEL) == CAN_RX1_IRQChannel) || \
N                                      ((CHANNEL) == CAN_SCE_IRQChannel) || \
N                                      ((CHANNEL) == EXTI9_5_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_CC_IRQChannel) || \
N                                      ((CHANNEL) == TIM2_IRQChannel) || \
N                                      ((CHANNEL) == TIM3_IRQChannel) || \
N                                      ((CHANNEL) == TIM4_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_ER_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_ER_IRQChannel) || \
N                                      ((CHANNEL) == SPI1_IRQChannel) || \
N                                      ((CHANNEL) == SPI2_IRQChannel) || \
N                                      ((CHANNEL) == USART1_IRQChannel) || \
N                                      ((CHANNEL) == USART2_IRQChannel) || \
N                                      ((CHANNEL) == USART3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI15_10_IRQChannel) || \
N                                      ((CHANNEL) == RTCAlarm_IRQChannel) || \
N                                      ((CHANNEL) == USBWakeUp_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_CC_IRQChannel) || \
N                                      ((CHANNEL) == ADC3_IRQChannel) || \
N                                      ((CHANNEL) == FSMC_IRQChannel) || \
N                                      ((CHANNEL) == SDIO_IRQChannel) || \
N                                      ((CHANNEL) == TIM5_IRQChannel) || \
N                                      ((CHANNEL) == SPI3_IRQChannel) || \
N                                      ((CHANNEL) == UART4_IRQChannel) || \
N                                      ((CHANNEL) == UART5_IRQChannel) || \
N                                      ((CHANNEL) == TIM6_IRQChannel) || \
N                                      ((CHANNEL) == TIM7_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
X#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) ||                                       ((CHANNEL) == PVD_IRQChannel) ||                                       ((CHANNEL) == TAMPER_IRQChannel) ||                                       ((CHANNEL) == RTC_IRQChannel) ||                                       ((CHANNEL) == FLASH_IRQChannel) ||                                       ((CHANNEL) == RCC_IRQChannel) ||                                       ((CHANNEL) == EXTI0_IRQChannel) ||                                       ((CHANNEL) == EXTI1_IRQChannel) ||                                       ((CHANNEL) == EXTI2_IRQChannel) ||                                       ((CHANNEL) == EXTI3_IRQChannel) ||                                       ((CHANNEL) == EXTI4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel5_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel6_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel7_IRQChannel) ||                                       ((CHANNEL) == ADC1_2_IRQChannel) ||                                       ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) ||                                       ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) ||                                       ((CHANNEL) == CAN_RX1_IRQChannel) ||                                       ((CHANNEL) == CAN_SCE_IRQChannel) ||                                       ((CHANNEL) == EXTI9_5_IRQChannel) ||                                       ((CHANNEL) == TIM1_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM1_UP_IRQChannel) ||                                       ((CHANNEL) == TIM1_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM1_CC_IRQChannel) ||                                       ((CHANNEL) == TIM2_IRQChannel) ||                                       ((CHANNEL) == TIM3_IRQChannel) ||                                       ((CHANNEL) == TIM4_IRQChannel) ||                                       ((CHANNEL) == I2C1_EV_IRQChannel) ||                                       ((CHANNEL) == I2C1_ER_IRQChannel) ||                                       ((CHANNEL) == I2C2_EV_IRQChannel) ||                                       ((CHANNEL) == I2C2_ER_IRQChannel) ||                                       ((CHANNEL) == SPI1_IRQChannel) ||                                       ((CHANNEL) == SPI2_IRQChannel) ||                                       ((CHANNEL) == USART1_IRQChannel) ||                                       ((CHANNEL) == USART2_IRQChannel) ||                                       ((CHANNEL) == USART3_IRQChannel) ||                                       ((CHANNEL) == EXTI15_10_IRQChannel) ||                                       ((CHANNEL) == RTCAlarm_IRQChannel) ||                                       ((CHANNEL) == USBWakeUp_IRQChannel) ||                                       ((CHANNEL) == TIM8_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM8_UP_IRQChannel) ||                                       ((CHANNEL) == TIM8_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM8_CC_IRQChannel) ||                                       ((CHANNEL) == ADC3_IRQChannel) ||                                       ((CHANNEL) == FSMC_IRQChannel) ||                                       ((CHANNEL) == SDIO_IRQChannel) ||                                       ((CHANNEL) == TIM5_IRQChannel) ||                                       ((CHANNEL) == SPI3_IRQChannel) ||                                       ((CHANNEL) == UART4_IRQChannel) ||                                       ((CHANNEL) == UART5_IRQChannel) ||                                       ((CHANNEL) == TIM6_IRQChannel) ||                                       ((CHANNEL) == TIM7_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
N
N
N/* System Handlers -----------------------------------------------------------*/
N#define SystemHandler_NMI            ((u32)0x00001F) /* NMI Handler */
N#define SystemHandler_HardFault      ((u32)0x000000) /* Hard Fault Handler */
N#define SystemHandler_MemoryManage   ((u32)0x043430) /* Memory Manage Handler */
N#define SystemHandler_BusFault       ((u32)0x547931) /* Bus Fault Handler */
N#define SystemHandler_UsageFault     ((u32)0x24C232) /* Usage Fault Handler */
N#define SystemHandler_SVCall         ((u32)0x01FF40) /* SVCall Handler */
N#define SystemHandler_DebugMonitor   ((u32)0x0A0080) /* Debug Monitor Handler */
N#define SystemHandler_PSV            ((u32)0x02829C) /* PSV Handler */
N#define SystemHandler_SysTick        ((u32)0x02C39A) /* SysTick Handler */
N
N#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                           ((HANDLER) == SystemHandler_BusFault) || \
N                                           ((HANDLER) == SystemHandler_UsageFault))
X#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                            ((HANDLER) == SystemHandler_BusFault) ||                                            ((HANDLER) == SystemHandler_UsageFault))
N
N#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                             ((HANDLER) == SystemHandler_BusFault) || \
N                                             ((HANDLER) == SystemHandler_UsageFault) || \
N                                             ((HANDLER) == SystemHandler_SVCall) || \
N                                             ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                             ((HANDLER) == SystemHandler_PSV) || \
N                                             ((HANDLER) == SystemHandler_SysTick))
X#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                              ((HANDLER) == SystemHandler_BusFault) ||                                              ((HANDLER) == SystemHandler_UsageFault) ||                                              ((HANDLER) == SystemHandler_SVCall) ||                                              ((HANDLER) == SystemHandler_DebugMonitor) ||                                              ((HANDLER) == SystemHandler_PSV) ||                                              ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                ((HANDLER) == SystemHandler_BusFault) || \
N                                                ((HANDLER) == SystemHandler_SVCall))
X#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                 ((HANDLER) == SystemHandler_BusFault) ||                                                 ((HANDLER) == SystemHandler_SVCall))
N
N#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) || \
N                                                ((HANDLER) == SystemHandler_PSV) || \
N                                                ((HANDLER) == SystemHandler_SysTick))
X#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) ||                                                 ((HANDLER) == SystemHandler_PSV) ||                                                 ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) || \
N                                          ((HANDLER) == SystemHandler_SysTick))
X#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) ||                                           ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                               ((HANDLER) == SystemHandler_BusFault) || \
N                                               ((HANDLER) == SystemHandler_UsageFault) || \
N                                               ((HANDLER) == SystemHandler_SVCall) || \
N                                               ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                               ((HANDLER) == SystemHandler_PSV) || \
N                                               ((HANDLER) == SystemHandler_SysTick))
X#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                ((HANDLER) == SystemHandler_BusFault) ||                                                ((HANDLER) == SystemHandler_UsageFault) ||                                                ((HANDLER) == SystemHandler_SVCall) ||                                                ((HANDLER) == SystemHandler_DebugMonitor) ||                                                ((HANDLER) == SystemHandler_PSV) ||                                                ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) || \
N                                                 ((HANDLER) == SystemHandler_MemoryManage) || \
N                                                 ((HANDLER) == SystemHandler_BusFault) || \
N                                                 ((HANDLER) == SystemHandler_UsageFault) || \
N                                                 ((HANDLER) == SystemHandler_DebugMonitor)) 
X#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) ||                                                  ((HANDLER) == SystemHandler_MemoryManage) ||                                                  ((HANDLER) == SystemHandler_BusFault) ||                                                  ((HANDLER) == SystemHandler_UsageFault) ||                                                  ((HANDLER) == SystemHandler_DebugMonitor)) 
N
N#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                  ((HANDLER) == SystemHandler_BusFault))
X#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                   ((HANDLER) == SystemHandler_BusFault))
N
N
N/* Vector Table Base ---------------------------------------------------------*/
N#define NVIC_VectTab_RAM             ((u32)0x20000000)
N#define NVIC_VectTab_FLASH           ((u32)0x08000000)
N
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N
N/* System Low Power ----------------------------------------------------------*/
N#define NVIC_LP_SEVONPEND            ((u8)0x10)
N#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
N
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N
N/* Preemption Priority Group -------------------------------------------------*/
N#define NVIC_PriorityGroup_0         ((u32)0x700) /* 0 bits for pre-emption priority
N                                                     4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((u32)0x600) /* 1 bits for pre-emption priority
N                                                     3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((u32)0x500) /* 2 bits for pre-emption priority
N                                                     2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((u32)0x400) /* 3 bits for pre-emption priority
N                                                     1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((u32)0x300) /* 4 bits for pre-emption priority
N                                                     0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x0007FFFF)
N#define IS_NVIC_BASE_PRI(PRI)   ((PRI) < 0x10)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid NVIC_DeInit(void);
Nvoid NVIC_SCBDeInit(void);
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SETPRIMASK(void);
Nvoid NVIC_RESETPRIMASK(void);
Nvoid NVIC_SETFAULTMASK(void);
Nvoid NVIC_RESETFAULTMASK(void);
Nvoid NVIC_BASEPRICONFIG(u32 NewPriority);
Nu32 NVIC_GetBASEPRI(void);
Nu16 NVIC_GetCurrentPendingIRQChannel(void);
NITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel);
Nvoid NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nvoid NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nu16 NVIC_GetCurrentActiveHandler(void);
NITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel);
Nu32 NVIC_GetCPUID(void);
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
Nvoid NVIC_GenerateSystemReset(void);
Nvoid NVIC_GenerateCoreReset(void);
Nvoid NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState);
Nvoid NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState);
Nvoid NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
N                                      u8 SystemHandlerSubPriority);
NITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler);
Nvoid NVIC_SetSystemHandlerPendingBit(u32 SystemHandler);
Nvoid NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler);
NITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler);
Nu32 NVIC_GetFaultHandlerSources(u32 SystemHandler);
Nu32 NVIC_GetFaultAddress(u32 SystemHandler);
N
N#endif /* __STM32F10x_NVIC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 15 ".\core\jpstm32_common.h" 2
N
N /* * * * * * * * * * * * * * * * * * * * * * * * * * * 
N  * 位带操作，将RAM区地址转换成位带别名区地址
N	* >reg 要转换的位所在的寄存器
N	* >bitn 要转换的位
N  * * * * * * * * * * * * * * * * * * * * * * * * * * */
N#define _BD(reg, bitn)\
N	*((vu32*)(((vu32)(&reg)&0xF0000000)+0x2000000\
N	+(((vu32)(&reg)&0xFFFFF)<<5) + (bitn<<2)))
X#define _BD(reg, bitn)	*((vu32*)(((vu32)(&reg)&0xF0000000)+0x2000000	+(((vu32)(&reg)&0xFFFFF)<<5) + (bitn<<2)))
N
N//中断触发方式
Ntypedef enum{
N    RISING = 0,FALLING,BOTH_EDGE
N}EXTI_TRIGGER_MODE;
N
N//触发中断或时事件
Ntypedef enum{
N    IRQ = 0,EVENT,BOTH_INT_EVENT
N}INT_EVENT_MODE;
N
N//???
Ntypedef enum{
N    PORTA = 0,PORTB,PORTC,PORTD,PORTE,PORTF,PORTG
N}PORT;
N
N#endif
L 14 ".\core\jpstm32_gpio.h" 2
N
N//引脚状态值
Ntypedef enum{
N	VAL_0=0, 	/*引脚值为低电平 逻辑0*/
N	VAL_1		/*引脚值为高电平 逻辑1*/
N} PIN_VAL; 
N//上拉、下拉状态
Ntypedef enum{
N	PULL_UP,	/*上拉电阻标记*/
N	PULL_DOWN	/*下拉电阻标记*/
N} PULL_STAT;
N
N//IO功能定义
N#define		O_GPPP		0x00	//0B0000	//通用推挽输出
N#define		O_GPOD		0x04	//0B0100	//通用开漏输出
N#define		O_AFPP		0x08	//0B1000	//复用推挽输出
N#define		O_AFOD		0x0c	//0b1100	//复用开漏输出
N#define		I_ANA		0x00	//0B0000	//模拟输入
N#define		I_FLO		0x04	//0B0100	//浮空输入
N#define		I_PULLUD	0x08	//0B1000	//上拉、下拉输入
N
N//输出模式定义
N#define		OMODE_RES			0x00	//0B00	//保留
N#define		OMODE_T10MHz		0x01	//0B01	//最高10MHz输出
N#define		OMODE_T02MHz		0x02	//0B10	//最高2MHz输出
N#define		OMODE_T50MHz		0x03	//0B11	//最高50MHz输出
N
N//I/O接口地址定义
N#define		GPIO_BASE		(APB2PERIPH_BASE+0x0800)
N#define		PORTA		0x0000
N#define		PORTB		0x0400
N#define		PORTC		0x0800
N#define		PORTD		0x0c00
N#define		PORTE		0x1000
N#define		PORTF		0x1400
N#define		PORTG		0x1800
N
N//引脚定义
N#define		Pin0		1<<0
N#define		Pin1		1<<1
N#define		Pin2		1<<2
N#define		Pin3		1<<3
N#define		Pin4		1<<4
N#define		Pin5		1<<5
N#define		Pin6		1<<6
N#define		Pin7		1<<7
N#define		Pin8		1<<8
N#define		Pin9		1<<9
N#define		PinA		1<<10
N#define		PinB		1<<11
N#define		PinC		1<<12
N#define		PinD		1<<13
N#define		PinE		1<<14
N#define		PinF		1<<15
N
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * Function:	set_gpio_port
N * Description: 配置GPIO端口
N * Input: 
N *	>PORTx,	端口名称 x=(A B C ...)
N *	>MODE, 输出模式设置, 用于设定端口输出频率 
N *	>PINx, 需要设置的引脚 Pin0~PinF 可以进行或操作
N *	>PULL_STAT, 设置引脚是否上拉
N * Output: NULL
N * Return: NULL
N * Others: NULL
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
Nvoid config_gpio(u32 PORTx, u32 MODE, u32 PINxs, PULL_STAT stat);
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * Function:	set_PINxs
N * Description: 设置某一I/O口的某(几)个引脚的值
N * Input: 
N *	>PORTx,	端口名称 x=(A B C ...)
N *	>PINx, 需要设置的引脚 Pin0~PinF 可以进行或操作
N *	>val, 要设置的值
N * Output: NULL
N * Return: NULL
N * Others: NULL
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
Nvoid set_PINxs(u32	PORTx, u32 PINxs, PIN_VAL val);
N
N
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * 位带操作
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N
N//GPIONx output
N#define PAxOut(x)	_BD(GPIOA->ODR, x)	//PORTAx output
N#define PBxOut(x)	_BD(GPIOB->ODR, x)	//PORTBx output
N#define PCxOut(x)	_BD(GPIOC->ODR, x)	//PORTCx output
N#define PDxOut(x)	_BD(GPIOD->ODR, x)	//PORTDx output
N#define PExOut(x)	_BD(GPIOE->ODR, x)	//PORTEx output
N#define PFxOut(x)	_BD(GPIOF->ODR, x)	//PORTFx output
N#define PGxOut(x)	_BD(GPIOG->ODR, x)	//PORTGx output
N//GPIONx input
N#define PAxIn(x)	_BD(GPIOA->IDR, x)	//PORTAx input
N#define PBxIn(x)	_BD(GPIOB->IDR, x)	//PORTBx input
N#define PCxIn(x)	_BD(GPIOC->IDR, x)	//PORTCx input
N#define PDxIn(x)	_BD(GPIOD->IDR, x)	//PORTDx input
N#define PExIn(x)	_BD(GPIOE->IDR, x)	//PORTEx input
N#define PFxIn(x)	_BD(GPIOF->IDR, x)	//PORTFx input
N#define PGxIn(x)	_BD(GPIOG->IDR, x)	//PORTGx input
N
N#endif
N
N
L 59 "devices\jpstm32_lcd.h" 2
N#include "stdlib.h"
L 1 "D:\Program Files\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 60 "devices\jpstm32_lcd.h" 2
N
N//横、竖屏切换
N#define	LCD_HOR_MODE	1
N#define	LCD_VER_MODE	0
N#define	LCD_VIEW_MODE	LCD_VER_MODE
N//背光控制
N#define	BLIGHT			PBxOut(0)
N#define	BLIGHT_ON		1
N#define	BLIGHT_OFF	0
N//扫描方向
N#define L2R_U2D  0 //left to right, up to down
N#define L2R_D2U  1 
N#define R2L_U2D  2 
N#define R2L_D2U  3 
N
N#define U2D_L2R  4
N#define U2D_R2L  5 
N#define D2U_L2R  6
N#define D2U_R2L  7
N//默认扫描方向
N#define DFT_SCAN_DIR  L2R_U2D
N/* ***********************************************************
N * 1.LCD9486的并口操作类似于SRAM的并口，STM32F103ZET6专门提供
N *   了针对SRAM/NOR FLASH、NAND Flash/PC Card操作的总线控制器
N *   FSMC(Flexible static memory controller)
N * 2.FSMC可以针对不同类型的外围设备设置不同的数据传输频率、通
N *   信方式等。当FSMC连接SRAM时其工作原理是：
N *		a)指定地址，在地址总线上指定某一个地址
N *		b)准备地址，需要一段时间进行计算该地址
N *		c)指定访问字节序，如果外设支持高低字节访问顺序设置则
N *		  需要配置此选项
N *		d)片选，FSMC可能同时连接多个外设 需要指定具体的设备
N *		e)读/写设置，确定对a)中指定的地址进行读操作还是写操作
N *		f)数据操作
N *		  读 将a)步骤中指定的地址内的数据交给数据总线
N *		  写 将数据总线上的数据写入a)步骤中指定的地址 
N *   上述步骤全部由FSMC自动完成，程序员在编程时只需关心要操作
N *   的地址与数据即可
N * 3.虽然LCD9486的并口与SRAM类似但是LCD9486没有地址线，编程时
N *   交互的数据需要通过LCD_RS信号线来区分写入LCD9486的是命令
N *   还是数据，操作时可以将LCD_RS信号线理解为地址。例如把LCD_RS
N *   连接到FSMC的A0引脚上，那么当FSMC对0x0000000地址进行写操作
N *   时使得A0引脚变为0，对LCD9486来说就是写入命令；当FSMC对0x01
N *   地址进行写操作时使得A0引脚变为1，对于LCD9486来说就是写入数
N *   据。JPIOT_STM32-V1开发板将LCD9486的RS引脚连接到了FSMC的A10
N *   引脚，即当我们访问0Bxxxx x0xx xxxx xxxx地址时表示向LCD写入
N *   命令，当访问0Bxxxx x1xx xxxx xxxx时表示向LCD写入数据。由于
N *   采用16位并口进行传输，内部总线地址与FSMC的地址对应关系为
N *   HADDR[25:1]-->FSMC[24:0]所以当RS连接到A10时访问的实际地址
N *   应该右移1位。为方便操作取相邻的两个地址(两字节为单位)来区
N *   分写入LCD的是命令还是数据，则上述两个地址变为0x7FE(写入命
N *   令)和0x800(写入数据)，将这两个地址再加上实际使用的存储区
N *   的首地址就是最终要操作的地址。所以有如下定义：
N * ***********************************************************/
Ntypedef struct {
N	u16		lcd_cmd;	//向LCD写入命令
N	u16		lcd_data;	//向LCD写入数据
N}LcdAddr;
N//LCD使用FSMC的Bank1存储区的第四区，所以其实地址为0x6C000000
N#define		LCD_BASE	((u32)(0x6C000000|0x000007FE))
N#define		LCD_ADDR	((LcdAddr*)LCD_BASE)
N
N//LCD设备描述结构体
Ntypedef struct {
N	u16		dev_no;
N	u16		width;	//宽度
N	u16		height;	//高度
N	u8		d_mode; //显示模式 HOR_MODE 横屏，VER_MODE 竖屏
N	u8		wr_cmd;	//写命令
N	u8		x_cmd;	//x坐标指令
N	u8		y_cmd;
N}LcdDev;
N
Nextern u16 POINT_COLOR;	//画笔颜色
Nextern u16 BACK_COLOR;  //背景色 
N
N//设备信息
Nextern LcdDev	Lcd_Dev;
N
N//颜色定义
N#define WHITE       0xFFFF
N#define BLACK      	0x0000	  
N#define BLUE       	0xF800 
N#define BRED        0XF81F
N#define GRED 				0XFFE0
N#define RED         0x001F
N#define MAGENTA     0xF81F
N#define GREEN       0x07E0
N#define CYAN        0x7FFF
N#define YELLOW      0x07FF
N#define BROWN 			0XBC40 
N#define BRRED 			0XFC07 
N#define GRAY  			0X8430 
N
N/**************************
N *	画笔定义
N **************************/
N//字符大小
Ntypedef enum
N{
N	P_S16EN = 16,
N	P_S32EN = 32,
N	P_S16CN = 16,
N	P_S32CN = 32
N}PenSize;
Ntypedef enum
N{
N	P_DIR_HOR,
N	P_DIR_VER
N}PenDirect;
Ntypedef enum
N{
N	P_SET_NOBRUSH, P_SET_BRUSH
N}PenBrush;
N//画笔
Ntypedef struct{
N	u16 color;
N	u16 bg_color;
N	PenSize p_size;
N	PenBrush brush;
N	PenDirect direct;
N}LcdPen;
N
N
N//初始化
Nvoid lcdInit(void);
N//清屏，全屏填充
Nvoid lcdClear(u16 color);
N//显示 开
Nvoid lcdDisplayOn(void);
N//显示 关
Nvoid lcdDisplayOff(void);
N//设置光标位置
Nvoid lcdSetCursor(u16 x, u16 y);
N//设定一个矩形显示区
Nvoid lcdSetWindow(u16 x_start, u16 y_start, u16 x_end, u16 y_end);
N
N//在屏幕上绘制一个像素点
Nvoid lcdDrawPoint(u16 x, u16 y, LcdPen* pen);
N
Nvoid lcdDrawLine(u16 x1,u16 y1,u16 x2,u16 y2,LcdPen* pen);
N
Nvoid lcdDrawRect(u16 x,u16 y,u16 width,u16 height,LcdPen* pen);
N
Nvoid lcd_write_cmd(void);
N
Nu16 LCD_DecToRGB(u8 R, u8 G, u8 B);
N
N//绘制一个字符,成功返回0,否则返回非零
Nu8 lcdDrawChr(u16 x, u16 y, u8 ch, LcdPen* p);
N//在指定位置绘制一个字符串
Nu8 lcdDrawStr(u16 x, u16 y, u8* str, LcdPen* p);
N//绘制一个由四个像素组成的点
Nvoid lcdDrawBigPoint(u16 x, u16 y, LcdPen* p);
N
N#endif
N
N
N
N
N
N
N
N
N
N
N
L 2 "devices\jpstm32_lcd.c" 2
N#include "jpstm32_lcd_font.h"
L 1 "devices\jpstm32_lcd_font.h" 1
N#ifndef __LCDFRONT_H_
N#define __LCDFRONT_H_
N//常用ASCII表
N//偏移量32
N//ASCII字符集
N//偏移量32
N//大小:12*6
N
Nconst unsigned char asc2_1206[95][12]={
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
N{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
N{0x00,0x00,0x30,0x00,0x40,0x00,0x30,0x00,0x40,0x00,0x00,0x00},/*""",2*/
N{0x09,0x00,0x0B,0xC0,0x3D,0x00,0x0B,0xC0,0x3D,0x00,0x09,0x00},/*"#",3*/
N{0x18,0xC0,0x24,0x40,0x7F,0xE0,0x22,0x40,0x31,0x80,0x00,0x00},/*"$",4*/
N{0x18,0x00,0x24,0xC0,0x1B,0x00,0x0D,0x80,0x32,0x40,0x01,0x80},/*"%",5*/
N{0x03,0x80,0x1C,0x40,0x27,0x40,0x1C,0x80,0x07,0x40,0x00,0x40},/*"&",6*/
N{0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x20,0x40,0x40,0x20},/*"(",8*/
N{0x00,0x00,0x40,0x20,0x20,0x40,0x1F,0x80,0x00,0x00,0x00,0x00},/*")",9*/
N{0x09,0x00,0x06,0x00,0x1F,0x80,0x06,0x00,0x09,0x00,0x00,0x00},/*"*",10*/
N{0x04,0x00,0x04,0x00,0x3F,0x80,0x04,0x00,0x04,0x00,0x00,0x00},/*"+",11*/
N{0x00,0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
N{0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x00},/*"-",13*/
N{0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
N{0x00,0x20,0x01,0xC0,0x06,0x00,0x38,0x00,0x40,0x00,0x00,0x00},/*"/",15*/
N{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"0",16*/
N{0x00,0x00,0x10,0x40,0x3F,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"1",17*/
N{0x18,0xC0,0x21,0x40,0x22,0x40,0x24,0x40,0x18,0x40,0x00,0x00},/*"2",18*/
N{0x10,0x80,0x20,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"3",19*/
N{0x02,0x00,0x0D,0x00,0x11,0x00,0x3F,0xC0,0x01,0x40,0x00,0x00},/*"4",20*/
N{0x3C,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x23,0x80,0x00,0x00},/*"5",21*/
N{0x1F,0x80,0x24,0x40,0x24,0x40,0x34,0x40,0x03,0x80,0x00,0x00},/*"6",22*/
N{0x30,0x00,0x20,0x00,0x27,0xC0,0x38,0x00,0x20,0x00,0x00,0x00},/*"7",23*/
N{0x1B,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"8",24*/
N{0x1C,0x00,0x22,0xC0,0x22,0x40,0x22,0x40,0x1F,0x80,0x00,0x00},/*"9",25*/
N{0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
N{0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
N{0x00,0x00,0x04,0x00,0x0A,0x00,0x11,0x00,0x20,0x80,0x40,0x40},/*"<",28*/
N{0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x00,0x00},/*"=",29*/
N{0x00,0x00,0x40,0x40,0x20,0x80,0x11,0x00,0x0A,0x00,0x04,0x00},/*">",30*/
N{0x18,0x00,0x20,0x00,0x23,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"?",31*/
N{0x1F,0x80,0x20,0x40,0x27,0x40,0x29,0x40,0x1F,0x40,0x00,0x00},/*"@",32*/
N{0x00,0x40,0x07,0xC0,0x39,0x00,0x0F,0x00,0x01,0xC0,0x00,0x40},/*"A",33*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"B",34*/
N{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x30,0x80,0x00,0x00},/*"C",35*/
N{0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"D",36*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x40,0x30,0xC0,0x00,0x00},/*"E",37*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x00,0x30,0x00,0x00,0x00},/*"F",38*/
N{0x0F,0x00,0x10,0x80,0x20,0x40,0x22,0x40,0x33,0x80,0x02,0x00},/*"G",39*/
N{0x20,0x40,0x3F,0xC0,0x04,0x00,0x04,0x00,0x3F,0xC0,0x20,0x40},/*"H",40*/
N{0x20,0x40,0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x00,0x00},/*"I",41*/
N{0x00,0x60,0x20,0x20,0x20,0x20,0x3F,0xC0,0x20,0x00,0x20,0x00},/*"J",42*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x0B,0x00,0x30,0xC0,0x20,0x40},/*"K",43*/
N{0x20,0x40,0x3F,0xC0,0x20,0x40,0x00,0x40,0x00,0x40,0x00,0xC0},/*"L",44*/
N{0x3F,0xC0,0x3C,0x00,0x03,0xC0,0x3C,0x00,0x3F,0xC0,0x00,0x00},/*"M",45*/
N{0x20,0x40,0x3F,0xC0,0x0C,0x40,0x23,0x00,0x3F,0xC0,0x20,0x00},/*"N",46*/
N{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"O",47*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"P",48*/
N{0x1F,0x80,0x21,0x40,0x21,0x40,0x20,0xE0,0x1F,0xA0,0x00,0x00},/*"Q",49*/
N{0x20,0x40,0x3F,0xC0,0x24,0x40,0x26,0x00,0x19,0xC0,0x00,0x40},/*"R",50*/
N{0x18,0xC0,0x24,0x40,0x24,0x40,0x22,0x40,0x31,0x80,0x00,0x00},/*"S",51*/
N{0x30,0x00,0x20,0x40,0x3F,0xC0,0x20,0x40,0x30,0x00,0x00,0x00},/*"T",52*/
N{0x20,0x00,0x3F,0x80,0x00,0x40,0x00,0x40,0x3F,0x80,0x20,0x00},/*"U",53*/
N{0x20,0x00,0x3E,0x00,0x01,0xC0,0x07,0x00,0x38,0x00,0x20,0x00},/*"V",54*/
N{0x38,0x00,0x07,0xC0,0x3C,0x00,0x07,0xC0,0x38,0x00,0x00,0x00},/*"W",55*/
N{0x20,0x40,0x39,0xC0,0x06,0x00,0x39,0xC0,0x20,0x40,0x00,0x00},/*"X",56*/
N{0x20,0x00,0x38,0x40,0x07,0xC0,0x38,0x40,0x20,0x00,0x00,0x00},/*"Y",57*/
N{0x30,0x40,0x21,0xC0,0x26,0x40,0x38,0x40,0x20,0xC0,0x00,0x00},/*"Z",58*/
N{0x00,0x00,0x00,0x00,0x7F,0xE0,0x40,0x20,0x40,0x20,0x00,0x00},/*"[",59*/
N{0x00,0x00,0x70,0x00,0x0C,0x00,0x03,0x80,0x00,0x40,0x00,0x00},/*"\",60*/
N{0x00,0x00,0x40,0x20,0x40,0x20,0x7F,0xE0,0x00,0x00,0x00,0x00},/*"]",61*/
N{0x00,0x00,0x20,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
N{0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10},/*"_",63*/
N{0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
N{0x00,0x00,0x02,0x80,0x05,0x40,0x05,0x40,0x03,0xC0,0x00,0x40},/*"a",65*/
N{0x20,0x00,0x3F,0xC0,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"b",66*/
N{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x06,0x40,0x00,0x00},/*"c",67*/
N{0x00,0x00,0x03,0x80,0x04,0x40,0x24,0x40,0x3F,0xC0,0x00,0x40},/*"d",68*/
N{0x00,0x00,0x03,0x80,0x05,0x40,0x05,0x40,0x03,0x40,0x00,0x00},/*"e",69*/
N{0x00,0x00,0x04,0x40,0x1F,0xC0,0x24,0x40,0x24,0x40,0x20,0x00},/*"f",70*/
N{0x00,0x00,0x02,0xE0,0x05,0x50,0x05,0x50,0x06,0x50,0x04,0x20},/*"g",71*/
N{0x20,0x40,0x3F,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"h",72*/
N{0x00,0x00,0x04,0x40,0x27,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"i",73*/
N{0x00,0x10,0x00,0x10,0x04,0x10,0x27,0xE0,0x00,0x00,0x00,0x00},/*"j",74*/
N{0x20,0x40,0x3F,0xC0,0x01,0x40,0x07,0x00,0x04,0xC0,0x04,0x40},/*"k",75*/
N{0x20,0x40,0x20,0x40,0x3F,0xC0,0x00,0x40,0x00,0x40,0x00,0x00},/*"l",76*/
N{0x07,0xC0,0x04,0x00,0x07,0xC0,0x04,0x00,0x03,0xC0,0x00,0x00},/*"m",77*/
N{0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"n",78*/
N{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"o",79*/
N{0x04,0x10,0x07,0xF0,0x04,0x50,0x04,0x40,0x03,0x80,0x00,0x00},/*"p",80*/
N{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x50,0x07,0xF0,0x00,0x10},/*"q",81*/
N{0x04,0x40,0x07,0xC0,0x02,0x40,0x04,0x00,0x04,0x00,0x00,0x00},/*"r",82*/
N{0x00,0x00,0x06,0x40,0x05,0x40,0x05,0x40,0x04,0xC0,0x00,0x00},/*"s",83*/
N{0x00,0x00,0x04,0x00,0x1F,0x80,0x04,0x40,0x00,0x40,0x00,0x00},/*"t",84*/
N{0x04,0x00,0x07,0x80,0x00,0x40,0x04,0x40,0x07,0xC0,0x00,0x40},/*"u",85*/
N{0x04,0x00,0x07,0x00,0x04,0xC0,0x01,0x80,0x06,0x00,0x04,0x00},/*"v",86*/
N{0x06,0x00,0x01,0xC0,0x07,0x00,0x01,0xC0,0x06,0x00,0x00,0x00},/*"w",87*/
N{0x04,0x40,0x06,0xC0,0x01,0x00,0x06,0xC0,0x04,0x40,0x00,0x00},/*"x",88*/
N{0x04,0x10,0x07,0x10,0x04,0xE0,0x01,0x80,0x06,0x00,0x04,0x00},/*"y",89*/
N{0x00,0x00,0x04,0x40,0x05,0xC0,0x06,0x40,0x04,0x40,0x00,0x00},/*"z",90*/
N{0x00,0x00,0x00,0x00,0x04,0x00,0x7B,0xE0,0x40,0x20,0x00,0x00},/*"{",91*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xF0,0x00,0x00,0x00,0x00},/*"|",92*/
N{0x00,0x00,0x40,0x20,0x7B,0xE0,0x04,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
N{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},/*"~",94*/
N}; 
Nconst unsigned char asc2_1608[95][16]={	  
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
N{0x00,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x00,0x00},/*""",2*/
N{0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x00,0x00},/*"#",3*/
N{0x00,0x00,0x0E,0x18,0x11,0x04,0x3F,0xFF,0x10,0x84,0x0C,0x78,0x00,0x00,0x00,0x00},/*"$",4*/
N{0x0F,0x00,0x10,0x84,0x0F,0x38,0x00,0xC0,0x07,0x78,0x18,0x84,0x00,0x78,0x00,0x00},/*"%",5*/
N{0x00,0x78,0x0F,0x84,0x10,0xC4,0x11,0x24,0x0E,0x98,0x00,0xE4,0x00,0x84,0x00,0x08},/*"&",6*/
N{0x08,0x00,0x68,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x18,0x18,0x20,0x04,0x40,0x02,0x00,0x00},/*"(",8*/
N{0x00,0x00,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
N{0x02,0x40,0x02,0x40,0x01,0x80,0x0F,0xF0,0x01,0x80,0x02,0x40,0x02,0x40,0x00,0x00},/*"*",10*/
N{0x00,0x80,0x00,0x80,0x00,0x80,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},/*"+",11*/
N{0x00,0x01,0x00,0x0D,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
N{0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*"-",13*/
N{0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
N{0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x01,0x80,0x06,0x00,0x18,0x00,0x20,0x00},/*"/",15*/
N{0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"0",16*/
N{0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"1",17*/
N{0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x11,0x84,0x0E,0x0C,0x00,0x00},/*"2",18*/
N{0x00,0x00,0x0C,0x18,0x10,0x04,0x11,0x04,0x11,0x04,0x12,0x88,0x0C,0x70,0x00,0x00},/*"3",19*/
N{0x00,0x00,0x00,0xE0,0x03,0x20,0x04,0x24,0x08,0x24,0x1F,0xFC,0x00,0x24,0x00,0x00},/*"4",20*/
N{0x00,0x00,0x1F,0x98,0x10,0x84,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00},/*"5",21*/
N{0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x18,0x88,0x00,0x70,0x00,0x00},/*"6",22*/
N{0x00,0x00,0x1C,0x00,0x10,0x00,0x10,0xFC,0x13,0x00,0x1C,0x00,0x10,0x00,0x00,0x00},/*"7",23*/
N{0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00},/*"8",24*/
N{0x00,0x00,0x07,0x00,0x08,0x8C,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00},/*"9",25*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
N{0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
N{0x00,0x00,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x00,0x00},/*"<",28*/
N{0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x00,0x00},/*"=",29*/
N{0x00,0x00,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x00},/*">",30*/
N{0x00,0x00,0x0E,0x00,0x12,0x00,0x10,0x0C,0x10,0x6C,0x10,0x80,0x0F,0x00,0x00,0x00},/*"?",31*/
N{0x03,0xE0,0x0C,0x18,0x13,0xE4,0x14,0x24,0x17,0xC4,0x08,0x28,0x07,0xD0,0x00,0x00},/*"@",32*/
N{0x00,0x04,0x00,0x3C,0x03,0xC4,0x1C,0x40,0x07,0x40,0x00,0xE4,0x00,0x1C,0x00,0x04},/*"A",33*/
N{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x0E,0x88,0x00,0x70,0x00,0x00},/*"B",34*/
N{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x1C,0x10,0x00,0x00},/*"C",35*/
N{0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"D",36*/
N{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x17,0xC4,0x10,0x04,0x08,0x18,0x00,0x00},/*"E",37*/
N{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x17,0xC0,0x10,0x00,0x08,0x00,0x00,0x00},/*"F",38*/
N{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x44,0x1C,0x78,0x00,0x40,0x00,0x00},/*"G",39*/
N{0x10,0x04,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFC,0x10,0x04},/*"H",40*/
N{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x00,0x00,0x00,0x00},/*"I",41*/
N{0x00,0x03,0x00,0x01,0x10,0x01,0x10,0x01,0x1F,0xFE,0x10,0x00,0x10,0x00,0x00,0x00},/*"J",42*/
N{0x10,0x04,0x1F,0xFC,0x11,0x04,0x03,0x80,0x14,0x64,0x18,0x1C,0x10,0x04,0x00,0x00},/*"K",43*/
N{0x10,0x04,0x1F,0xFC,0x10,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x0C,0x00,0x00},/*"L",44*/
N{0x10,0x04,0x1F,0xFC,0x1F,0x00,0x00,0xFC,0x1F,0x00,0x1F,0xFC,0x10,0x04,0x00,0x00},/*"M",45*/
N{0x10,0x04,0x1F,0xFC,0x0C,0x04,0x03,0x00,0x00,0xE0,0x10,0x18,0x1F,0xFC,0x10,0x00},/*"N",46*/
N{0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"O",47*/
N{0x10,0x04,0x1F,0xFC,0x10,0x84,0x10,0x80,0x10,0x80,0x10,0x80,0x0F,0x00,0x00,0x00},/*"P",48*/
N{0x07,0xF0,0x08,0x18,0x10,0x24,0x10,0x24,0x10,0x1C,0x08,0x0A,0x07,0xF2,0x00,0x00},/*"Q",49*/
N{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x11,0xC0,0x11,0x30,0x0E,0x0C,0x00,0x04},/*"R",50*/
N{0x00,0x00,0x0E,0x1C,0x11,0x04,0x10,0x84,0x10,0x84,0x10,0x44,0x1C,0x38,0x00,0x00},/*"S",51*/
N{0x18,0x00,0x10,0x00,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x00,0x18,0x00,0x00,0x00},/*"T",52*/
N{0x10,0x00,0x1F,0xF8,0x10,0x04,0x00,0x04,0x00,0x04,0x10,0x04,0x1F,0xF8,0x10,0x00},/*"U",53*/
N{0x10,0x00,0x1E,0x00,0x11,0xE0,0x00,0x1C,0x00,0x70,0x13,0x80,0x1C,0x00,0x10,0x00},/*"V",54*/
N{0x1F,0xC0,0x10,0x3C,0x00,0xE0,0x1F,0x00,0x00,0xE0,0x10,0x3C,0x1F,0xC0,0x00,0x00},/*"W",55*/
N{0x10,0x04,0x18,0x0C,0x16,0x34,0x01,0xC0,0x01,0xC0,0x16,0x34,0x18,0x0C,0x10,0x04},/*"X",56*/
N{0x10,0x00,0x1C,0x00,0x13,0x04,0x00,0xFC,0x13,0x04,0x1C,0x00,0x10,0x00,0x00,0x00},/*"Y",57*/
N{0x08,0x04,0x10,0x1C,0x10,0x64,0x10,0x84,0x13,0x04,0x1C,0x04,0x10,0x18,0x00,0x00},/*"Z",58*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x00,0x00},/*"[",59*/
N{0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x60,0x00,0x1C,0x00,0x03,0x00,0x00},/*"\",60*/
N{0x00,0x00,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
N{0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00},/*"^",62*/
N{0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01},/*"_",63*/
N{0x00,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
N{0x00,0x00,0x00,0x98,0x01,0x24,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xFC,0x00,0x04},/*"a",65*/
N{0x10,0x00,0x1F,0xFC,0x00,0x88,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"b",66*/
N{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x00},/*"c",67*/
N{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x11,0x08,0x1F,0xFC,0x00,0x04},/*"d",68*/
N{0x00,0x00,0x00,0xF8,0x01,0x44,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xC8,0x00,0x00},/*"e",69*/
N{0x00,0x00,0x01,0x04,0x01,0x04,0x0F,0xFC,0x11,0x04,0x11,0x04,0x11,0x00,0x18,0x00},/*"f",70*/
N{0x00,0x00,0x00,0xD6,0x01,0x29,0x01,0x29,0x01,0x29,0x01,0xC9,0x01,0x06,0x00,0x00},/*"g",71*/
N{0x10,0x04,0x1F,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"h",72*/
N{0x00,0x00,0x01,0x04,0x19,0x04,0x19,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"i",73*/
N{0x00,0x00,0x00,0x03,0x00,0x01,0x01,0x01,0x19,0x01,0x19,0xFE,0x00,0x00,0x00,0x00},/*"j",74*/
N{0x10,0x04,0x1F,0xFC,0x00,0x24,0x00,0x40,0x01,0xB4,0x01,0x0C,0x01,0x04,0x00,0x00},/*"k",75*/
N{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"l",76*/
N{0x01,0x04,0x01,0xFC,0x01,0x04,0x01,0x00,0x01,0xFC,0x01,0x04,0x01,0x00,0x00,0xFC},/*"m",77*/
N{0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"n",78*/
N{0x00,0x00,0x00,0xF8,0x01,0x04,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0xF8,0x00,0x00},/*"o",79*/
N{0x01,0x01,0x01,0xFF,0x00,0x85,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"p",80*/
N{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x05,0x01,0xFF,0x00,0x01},/*"q",81*/
N{0x01,0x04,0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x04,0x01,0x00,0x01,0x80,0x00,0x00},/*"r",82*/
N{0x00,0x00,0x00,0xCC,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x98,0x00,0x00},/*"s",83*/
N{0x00,0x00,0x01,0x00,0x01,0x00,0x07,0xF8,0x01,0x04,0x01,0x04,0x00,0x00,0x00,0x00},/*"t",84*/
N{0x01,0x00,0x01,0xF8,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0x08,0x01,0xFC,0x00,0x04},/*"u",85*/
N{0x01,0x00,0x01,0x80,0x01,0x70,0x00,0x0C,0x00,0x10,0x01,0x60,0x01,0x80,0x01,0x00},/*"v",86*/
N{0x01,0xF0,0x01,0x0C,0x00,0x30,0x01,0xC0,0x00,0x30,0x01,0x0C,0x01,0xF0,0x01,0x00},/*"w",87*/
N{0x00,0x00,0x01,0x04,0x01,0x8C,0x00,0x74,0x01,0x70,0x01,0x8C,0x01,0x04,0x00,0x00},/*"x",88*/
N{0x01,0x01,0x01,0x81,0x01,0x71,0x00,0x0E,0x00,0x18,0x01,0x60,0x01,0x80,0x01,0x00},/*"y",89*/
N{0x00,0x00,0x01,0x84,0x01,0x0C,0x01,0x34,0x01,0x44,0x01,0x84,0x01,0x0C,0x00,0x00},/*"z",90*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x3E,0xFC,0x40,0x02,0x40,0x02},/*"{",91*/
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
N{0x00,0x00,0x40,0x02,0x40,0x02,0x3E,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
N{0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/*"~",94*/
N};
N//以下为32*32 的0-0x95号字体，__ASIC2_3232_ == 1 为常规，2为粗体
N//  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
N#define __ASIC2_3232_		2
N#if __ASIC2_3232_ == 1
X#if 2 == 1
Sconst unsigned char asc2_3210[95][64]={
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//" ",0
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x00,0xC0,0x07,0xFF,0xE1,0xE0,0x07,0xF0,0x01,0xE0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"!",1
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x01,0xC0,0x00,0x00,0x07,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x1C,0x20,0x00,0x00,0x01,0xC0,0x00,0x00,0x07,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//""",2
S{ 0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0F,0xE0,0x00,0x1F,0xFC,0x00,0x03,0xF8,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0F,0xE0,0x00,0x1F,0xFC,0x00,0x03,0xF8,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x00,0x00,0x00},//"#",3
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x78,0x07,0xC0,0x00,0xFC,0x06,0x40,0x01,0x0E,0x00,0x20,0x03,0x07,0x00,0x20,0x02,0x03,0x80,0x20,0x0F,0xFF,0xFF,0xFC,0x02,0x01,0xC0,0x20,0x02,0x00,0xE0,0x60,0x01,0x30,0x70,0x40,0x01,0xF0,0x3F,0x80,0x00,0xF0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"$",4
S{ 0x00,0xFE,0x00,0x00,0x01,0xFF,0x00,0x00,0x03,0x01,0x80,0x00,0x02,0x00,0x80,0x60,0x03,0x01,0x81,0xC0,0x01,0xFF,0x07,0x00,0x00,0xFE,0x18,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0xBF,0x00,0x00,0x0C,0xFF,0xC0,0x00,0x71,0x80,0x60,0x01,0xC1,0x00,0x20,0x03,0x01,0x80,0x60,0x00,0x00,0xFF,0xC0,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x00},//"%",5
S{ 0x00,0x00,0x1F,0x00,0x00,0x00,0x7F,0xC0,0x00,0xFC,0xC0,0xC0,0x01,0xFF,0x80,0x60,0x03,0x03,0xE0,0x20,0x02,0x02,0x78,0x20,0x02,0x06,0x1E,0x20,0x03,0xFC,0x07,0x40,0x01,0xF0,0x03,0x80,0x00,0x01,0x03,0xC0,0x00,0x01,0x1C,0x60,0x00,0x01,0xE0,0x20,0x00,0x01,0x00,0x20,0x00,0x01,0x00,0x40,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00},//"&",6
S{ 0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x1C,0x60,0x00,0x00,0x1C,0x40,0x00,0x00,0x1F,0x80,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"'",7
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFF,0x00,0x00,0x78,0x07,0xC0,0x01,0xC0,0x00,0xE0,0x03,0x00,0x00,0x30,0x04,0x00,0x00,0x08,0x08,0x00,0x00,0x04,0x10,0x00,0x00,0x02,0x00,0x00,0x00,0x00},//"(",8
S{ 0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x02,0x08,0x00,0x00,0x04,0x04,0x00,0x00,0x08,0x03,0x00,0x00,0x30,0x01,0xC0,0x00,0xE0,0x00,0x78,0x07,0xC0,0x00,0x3F,0xFF,0x00,0x00,0x07,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//")",9
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x18,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x06,0x30,0x00,0x00,0x03,0x60,0x00,0x00,0x61,0x43,0x80,0x00,0xFF,0xFF,0x80,0x00,0x61,0x43,0x00,0x00,0x03,0x60,0x00,0x00,0x06,0x30,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x0C,0x18,0x00,0x00,0x00,0x00,0x00},//"*",10
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x7F,0xFF,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00},//"+",11
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xE3,0x00,0x00,0x00,0xE2,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//",",12
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00},//"-",13
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x01,0xE0,0x00,0x00,0x01,0xE0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//".",14
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x0E,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x0E,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x0E,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"/",15
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x7F,0xFF,0x00,0x00,0xF0,0x07,0x80,0x01,0x80,0x00,0xC0,0x03,0x00,0x00,0x60,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x01,0x80,0x00,0xC0,0x00,0xE0,0x03,0x80,0x00,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00},//"0",16
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x60,0x01,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"1",17
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0xE0,0x00,0x98,0x01,0x60,0x01,0x00,0x02,0x60,0x02,0x00,0x04,0x60,0x02,0x00,0x08,0x60,0x02,0x00,0x10,0x60,0x02,0x00,0x20,0x60,0x02,0x00,0x40,0x60,0x03,0x00,0x80,0x60,0x01,0x83,0x00,0x60,0x01,0xFE,0x00,0xE0,0x00,0x7C,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"2",18
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x07,0x80,0x01,0xF0,0x07,0xC0,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x03,0x03,0x80,0x20,0x01,0x86,0x80,0x40,0x01,0xFC,0xC0,0xC0,0x00,0x78,0x7F,0x80,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"3",19
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x48,0x00,0x00,0x01,0x88,0x00,0x00,0x06,0x08,0x00,0x00,0x0C,0x08,0x10,0x00,0x30,0x08,0x10,0x00,0x40,0x08,0x10,0x01,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xF0,0x00,0x00,0x08,0x10,0x00,0x00,0x08,0x10,0x00,0x00,0x08,0x10,0x00,0x00,0x00,0x00},//"4",20
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x1F,0x86,0x40,0x03,0xE1,0x00,0x20,0x03,0x02,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x06,0x00,0x40,0x03,0x03,0x01,0xC0,0x03,0x01,0xFF,0x80,0x03,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"5",21
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x00,0x00,0x3F,0xFF,0x00,0x00,0x70,0xC3,0x80,0x00,0x81,0x80,0xC0,0x01,0x01,0x00,0x60,0x03,0x02,0x00,0x20,0x02,0x02,0x00,0x20,0x02,0x02,0x00,0x20,0x02,0x02,0x00,0x20,0x02,0x03,0x00,0x40,0x01,0xC1,0x80,0xC0,0x00,0xC0,0xFF,0x80,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00},//"6",22
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x07,0xE0,0x03,0x00,0x3F,0xE0,0x03,0x01,0xC0,0x00,0x03,0x06,0x00,0x00,0x03,0x18,0x00,0x00,0x03,0x60,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"7",23
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x78,0x3F,0x80,0x00,0xFC,0x60,0xC0,0x01,0x8E,0xC0,0x40,0x03,0x07,0x80,0x20,0x02,0x03,0x00,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0xC0,0x20,0x03,0x01,0xE0,0x40,0x01,0x86,0x70,0xC0,0x00,0xFC,0x3F,0x80,0x00,0x78,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"8",24
S{ 0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0xFF,0x81,0xC0,0x01,0xC0,0xC1,0xC0,0x01,0x00,0x60,0x20,0x02,0x00,0x20,0x20,0x02,0x00,0x20,0x20,0x02,0x00,0x20,0x20,0x02,0x00,0x20,0x60,0x02,0x00,0x40,0xC0,0x01,0x00,0xC1,0x80,0x00,0xC1,0x8F,0x00,0x00,0x7F,0xFE,0x00,0x00,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"9",25
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xC0,0x00,0x07,0x81,0xE0,0x00,0x07,0x81,0xE0,0x00,0x03,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//":",26
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x66,0x00,0x06,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//";",27
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0xC0,0x00,0x00,0x03,0x60,0x00,0x00,0x06,0x30,0x00,0x00,0x0C,0x18,0x00,0x00,0x18,0x0C,0x00,0x00,0x30,0x06,0x00,0x00,0x60,0x03,0x00,0x00,0xC0,0x01,0x80,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0x20,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"<",28
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x00,0x00,0x00},//"=",29
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x02,0x00,0x00,0x20,0x01,0x00,0x00,0x40,0x00,0xC0,0x01,0x80,0x00,0x60,0x03,0x00,0x00,0x30,0x06,0x00,0x00,0x18,0x0C,0x00,0x00,0x0C,0x18,0x00,0x00,0x06,0x30,0x00,0x00,0x03,0x60,0x00,0x00,0x01,0xC0,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//">",30
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x01,0xF8,0x00,0x00,0x02,0x38,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0xC0,0x04,0x00,0x79,0xE0,0x04,0x00,0x81,0xE0,0x04,0x01,0x00,0xC0,0x04,0x03,0x00,0x00,0x02,0x02,0x00,0x00,0x03,0x06,0x00,0x00,0x01,0xFC,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00},//"?",31
S{ 0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0x70,0x07,0x80,0x00,0xC0,0x00,0xC0,0x01,0x01,0xF8,0x40,0x03,0x07,0xFC,0x20,0x02,0x1E,0x04,0x20,0x02,0x30,0x08,0x20,0x02,0x20,0x30,0x20,0x02,0x3F,0xFC,0x20,0x01,0x3F,0x04,0x40,0x01,0x80,0x0C,0xC0,0x00,0xE0,0x31,0x80,0x00,0x1F,0xC2,0x00,0x00,0x00,0x00,0x00},//"@",32
S{ 0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x60,0x00,0x00,0x03,0xE0,0x00,0x00,0x3E,0x20,0x00,0x03,0xE0,0x20,0x00,0x3E,0x20,0x00,0x03,0xE0,0x20,0x00,0x03,0x80,0x20,0x00,0x07,0xFC,0x20,0x00,0x00,0x3F,0xE0,0x00,0x00,0x03,0xFE,0x20,0x00,0x00,0x3F,0xE0,0x00,0x00,0x01,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"A",33
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x03,0x03,0x00,0x20,0x01,0x86,0x80,0x60,0x01,0xFC,0xC0,0xC0,0x00,0xF8,0x7F,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},//"B",34
S{ 0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFF,0x00,0x00,0x70,0x07,0x80,0x00,0xC0,0x00,0xC0,0x01,0x00,0x00,0x40,0x03,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x01,0x00,0x00,0x40,0x01,0x80,0x00,0xC0,0x03,0xC0,0x01,0x80,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00},//"C",35
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x01,0x00,0x00,0x40,0x01,0x80,0x00,0xC0,0x00,0xF0,0x07,0x80,0x00,0x7F,0xFE,0x00,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00},//"D",36
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x03,0x80,0x20,0x02,0x0F,0xE0,0x20,0x03,0x00,0x00,0x60,0x03,0xC0,0x00,0xE0,0x00,0x60,0x03,0x00,0x00,0x00,0x00,0x00},//"E",37
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x00,0x02,0x01,0x00,0x00,0x02,0x01,0x00,0x00,0x02,0x01,0x00,0x00,0x02,0x03,0x80,0x00,0x03,0x0F,0xE0,0x00,0x03,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x60,0x00,0x00},//"F",38
S{ 0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0x70,0x07,0x80,0x01,0xC0,0x01,0xC0,0x01,0x00,0x00,0x40,0x03,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x01,0x00,0x20,0x20,0x01,0x00,0x20,0x40,0x03,0xC0,0x3F,0x80,0x00,0x30,0x3F,0x80,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00},//"G",39
S{ 0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"H",40
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"I",41
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x01,0x02,0x00,0x00,0x01,0x02,0x00,0x00,0x03,0x02,0x00,0x00,0x06,0x03,0xFF,0xFF,0xFC,0x03,0xFF,0xFF,0xF8,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"J",42
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0xC0,0x20,0x02,0x01,0x00,0x20,0x00,0x07,0x80,0x00,0x00,0x0F,0xE0,0x00,0x00,0x30,0xF8,0x00,0x02,0x60,0x3E,0x20,0x03,0x80,0x0F,0x20,0x03,0x00,0x03,0xE0,0x02,0x00,0x00,0xE0,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x20},//"K",43
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00},//"L",44
S{ 0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xE0,0x00,0x20,0x03,0xFF,0x00,0x20,0x00,0x1F,0xF0,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x0F,0xE0,0x00,0x00,0x1E,0x00,0x00,0x03,0xE0,0x00,0x00,0x3E,0x00,0x20,0x03,0xE0,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20},//"M",45
S{ 0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0x80,0x00,0x20,0x03,0xF0,0x00,0x20,0x00,0xFC,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x07,0xC0,0x00,0x00,0x01,0xF0,0x00,0x00,0x00,0x7C,0x00,0x02,0x00,0x1F,0x80,0x02,0x00,0x07,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"N",46
S{ 0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0xF0,0x07,0x80,0x01,0x80,0x00,0xC0,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x01,0x00,0x00,0x40,0x01,0x80,0x00,0xC0,0x00,0xF0,0x03,0x80,0x00,0x3F,0xFE,0x00,0x00,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00},//"O",47
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x00,0x02,0x00,0x80,0x00,0x02,0x00,0x80,0x00,0x02,0x00,0x80,0x00,0x03,0x01,0x80,0x00,0x01,0x83,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00},//"P",48
S{ 0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x7F,0xFF,0x00,0x00,0xF0,0x03,0x80,0x01,0x80,0x01,0xC0,0x01,0x00,0x06,0x40,0x02,0x00,0x04,0x20,0x02,0x00,0x04,0x20,0x02,0x00,0x06,0x20,0x02,0x00,0x03,0xE0,0x01,0x00,0x00,0xF8,0x01,0x80,0x00,0x5C,0x00,0xE0,0x03,0x8C,0x00,0x3F,0xFF,0x0C,0x00,0x0F,0xFC,0x18,0x00,0x00,0x00,0x00},//"Q",49
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x80,0x00,0x02,0x01,0xE0,0x00,0x02,0x01,0xFC,0x00,0x03,0x03,0x3F,0x80,0x01,0x86,0x07,0xE0,0x01,0xFC,0x00,0xE0,0x00,0xF8,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"R",50
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x06,0x00,0x00,0xFE,0x01,0xE0,0x01,0x86,0x00,0xC0,0x03,0x03,0x00,0x40,0x02,0x03,0x00,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0xC0,0x20,0x02,0x00,0xC0,0x20,0x01,0x00,0xE0,0x60,0x01,0x80,0x70,0xC0,0x03,0xE0,0x3F,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},//"S",51
S{ 0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},//"T",52
S{ 0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x03,0xFF,0xFF,0xC0,0x02,0x00,0x00,0x40,0x02,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x02,0x00,0x00,0x40,0x02,0x00,0x00,0x80,0x03,0xFF,0xFF,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"U",53
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xFC,0x00,0x00,0x02,0x3F,0xC0,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x7F,0x80,0x00,0x00,0x07,0xE0,0x00,0x00,0x07,0x80,0x00,0x00,0x78,0x00,0x02,0x03,0xC0,0x00,0x02,0x3C,0x00,0x00,0x03,0xC0,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"V",54
S{ 0x02,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xFF,0x80,0x00,0x02,0x3F,0xFE,0x00,0x02,0x00,0x7F,0xE0,0x00,0x00,0x0F,0x00,0x02,0x00,0xF0,0x00,0x03,0xEF,0x00,0x00,0x03,0xFF,0x80,0x00,0x02,0x0F,0xFE,0x00,0x00,0x00,0x3F,0xE0,0x00,0x00,0x1F,0x00,0x02,0x07,0xE0,0x00,0x03,0xF8,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"W",55
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x80,0x00,0xE0,0x03,0xF0,0x03,0x20,0x02,0xFC,0x0C,0x20,0x02,0x1F,0x30,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xF0,0x00,0x02,0x18,0x7C,0x00,0x02,0x60,0x1F,0x20,0x03,0x80,0x03,0xE0,0x02,0x00,0x00,0xE0,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"X",56
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xF8,0x00,0x00,0x02,0x3E,0x00,0x20,0x02,0x0F,0xC0,0x20,0x00,0x01,0xFF,0xE0,0x00,0x00,0x7F,0xE0,0x00,0x03,0x80,0x20,0x02,0x1C,0x00,0x20,0x02,0x70,0x00,0x00,0x03,0x80,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"Y",57
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x60,0x00,0xE0,0x03,0x80,0x03,0xE0,0x03,0x00,0x0F,0xA0,0x02,0x00,0x3E,0x20,0x02,0x00,0xF8,0x20,0x02,0x03,0xE0,0x20,0x02,0x0F,0x80,0x20,0x02,0x3E,0x00,0x20,0x02,0x78,0x00,0x20,0x03,0xE0,0x00,0x60,0x03,0x80,0x00,0xE0,0x02,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"Z",58
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"[",59
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"\",60
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x1F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"]",61
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"^",62
S{ 0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01},//"_",63
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"`",64
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x01,0x8F,0xC0,0x00,0x03,0x8C,0x60,0x00,0x06,0x18,0x20,0x00,0x04,0x10,0x20,0x00,0x04,0x10,0x20,0x00,0x04,0x20,0x20,0x00,0x04,0x20,0x40,0x00,0x06,0x20,0x40,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00},//"a",65
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xC0,0x00,0x01,0x80,0xC0,0x00,0x02,0x00,0x60,0x00,0x02,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x40,0x00,0x03,0x00,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00},//"b",66
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0x81,0xC0,0x00,0x02,0x00,0x40,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x03,0xC0,0x40,0x00,0x01,0xC0,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"c",67
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0x80,0xC0,0x00,0x06,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x02,0x04,0x00,0x40,0x02,0x02,0x00,0x80,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00},//"d",68
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0x11,0xC0,0x00,0x02,0x10,0x40,0x00,0x04,0x10,0x60,0x00,0x04,0x10,0x20,0x00,0x04,0x10,0x20,0x00,0x04,0x10,0x20,0x00,0x06,0x10,0x20,0x00,0x03,0x10,0x40,0x00,0x01,0xF0,0xC0,0x00,0x00,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"e",69
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x7F,0xFF,0xE0,0x01,0xFF,0xFF,0xE0,0x01,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x02,0x04,0x00,0x20,0x02,0x04,0x00,0x20,0x02,0x04,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0xC0,0x00,0x00,0x01,0xC0,0x00,0x00},//"f",70
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0xE3,0x3E,0x00,0x03,0xFF,0xC2,0x00,0x02,0x0C,0xC3,0x00,0x04,0x04,0xC1,0x00,0x04,0x04,0xC1,0x00,0x04,0x04,0xC1,0x00,0x04,0x04,0xC1,0x00,0x06,0x0C,0xC1,0x00,0x03,0xF8,0xC3,0x00,0x05,0xF0,0x62,0x00,0x06,0x00,0x7E,0x00,0x06,0x00,0x3C,0x00,0x00,0x00,0x00},//"g",71
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x01,0x00,0x20,0x00,0x02,0x00,0x20,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x03,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20},//"h",72
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x03,0x87,0xFF,0xE0,0x03,0x8F,0xFF,0xE0,0x03,0x80,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"i",73
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x03,0x00,0x04,0x00,0x06,0x03,0x87,0xFF,0xFC,0x03,0x8F,0xFF,0xF8,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"j",74
S{ 0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x00,0x08,0x20,0x00,0x00,0x10,0x20,0x00,0x00,0x30,0x00,0x00,0x00,0xFC,0x00,0x00,0x05,0x8E,0x00,0x00,0x07,0x07,0xA0,0x00,0x06,0x01,0xE0,0x00,0x04,0x00,0xE0,0x00,0x04,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"k",75
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"l",76
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x02,0x00,0x20,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x02,0x00,0x20,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"m",77
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x01,0x00,0x20,0x00,0x02,0x00,0x20,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x03,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20},//"n",78
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0xFF,0x80,0x00,0x03,0x81,0xC0,0x00,0x02,0x00,0x40,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x02,0x00,0x40,0x00,0x03,0x81,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00},//"o",79
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x07,0xFF,0xFF,0x00,0x0F,0xFF,0xFF,0x00,0x01,0x00,0xC1,0x00,0x02,0x00,0x41,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x40,0x00,0x03,0x01,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00},//"p",80
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0x80,0xC0,0x00,0x02,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x02,0x00,0x41,0x00,0x03,0x00,0xC1,0x00,0x03,0xFF,0xFF,0x00,0x07,0xFF,0xFF,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01},//"q",81
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x00,0xC0,0x20,0x00,0x01,0x00,0x20,0x00,0x02,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00},//"r",82
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x01,0xC0,0xE0,0x00,0x03,0xE0,0x40,0x00,0x06,0x30,0x20,0x00,0x04,0x30,0x20,0x00,0x04,0x18,0x20,0x00,0x04,0x18,0x20,0x00,0x04,0x18,0x20,0x00,0x04,0x0C,0x20,0x00,0x02,0x0C,0x60,0x00,0x03,0x07,0xC0,0x00,0x07,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"s",83
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x1F,0xFF,0x80,0x00,0xFF,0xFF,0xC0,0x00,0x04,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x40,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"t",84
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x0F,0xFF,0xC0,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x04,0x00,0x40,0x00,0x04,0x00,0x80,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xC0,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40},//"u",85
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x07,0xF0,0x00,0x00,0x04,0xFE,0x00,0x00,0x04,0x1F,0xC0,0x00,0x00,0x03,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x1C,0x00,0x00,0x04,0x60,0x00,0x00,0x07,0x80,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"v",86
S{ 0x00,0x04,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xFC,0x00,0x00,0x04,0x3F,0x80,0x00,0x00,0x03,0xE0,0x00,0x04,0x0F,0x80,0x00,0x06,0xF0,0x00,0x00,0x07,0xF0,0x00,0x00,0x07,0xFF,0x80,0x00,0x04,0x0F,0xE0,0x00,0x00,0x03,0x80,0x00,0x04,0x3C,0x00,0x00,0x07,0xC0,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00},//"w",87
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x60,0x00,0x07,0x00,0xE0,0x00,0x07,0x83,0x20,0x00,0x07,0xE6,0x00,0x00,0x04,0xF8,0x00,0x00,0x00,0x3C,0x00,0x00,0x04,0x5E,0x20,0x00,0x05,0x87,0xA0,0x00,0x06,0x01,0xE0,0x00,0x04,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00},//"x",88
S{ 0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x03,0x00,0x07,0x00,0x03,0x00,0x07,0xE0,0x01,0x00,0x04,0xF8,0x01,0x00,0x04,0x1F,0x02,0x00,0x00,0x07,0xFC,0x00,0x00,0x00,0xE0,0x00,0x00,0x07,0x00,0x00,0x04,0x38,0x00,0x00,0x07,0xC0,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00},//"y",89
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x60,0x00,0x06,0x00,0xE0,0x00,0x04,0x03,0xE0,0x00,0x04,0x07,0xA0,0x00,0x04,0x0E,0x20,0x00,0x04,0x3C,0x20,0x00,0x04,0x70,0x20,0x00,0x05,0xE0,0x20,0x00,0x07,0x80,0x20,0x00,0x07,0x00,0x60,0x00,0x04,0x00,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"z",90
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0x40,0x00,0x07,0xFE,0x3F,0xF8,0x08,0x00,0x00,0x04,0x10,0x00,0x00,0x02,0x10,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"{",91
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"|",92
S{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x02,0x10,0x00,0x00,0x02,0x08,0x00,0x00,0x04,0x07,0xFE,0x3F,0xF8,0x00,0x01,0x40,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"}",93
S{ 0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"~",94
S	
S};
N#elif __ASIC2_3232_ == 2
X#elif 2 == 2
Nconst unsigned char asc2_3210[95][64]={
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//" ",0
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x00,0xC0,0x07,0xFF,0xE1,0xE0,0x07,0xFF,0xE1,0xE0,0x07,0xF0,0x01,0xE0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"!",1
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x01,0xE0,0x00,0x00,0x07,0xC0,0x00,0x00,0x1F,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x1E,0x20,0x00,0x00,0x1D,0xE0,0x00,0x00,0x07,0xC0,0x00,0x00,0x1F,0x80,0x00,0x00,0x1F,0x00,0x00,0x00,0x1E,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//""",2
N{0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0F,0xE0,0x00,0x1F,0xFF,0xE0,0x03,0xFF,0xFC,0x00,0x03,0xF8,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0F,0xE0,0x00,0x1F,0xFF,0xE0,0x03,0xFF,0xFC,0x00,0x03,0xF8,0x0C,0x00,0x00,0x18,0x0C,0x00,0x00,0x18,0x0C,0x00},//"#",3
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x78,0x07,0xC0,0x00,0xFC,0x07,0xC0,0x01,0xFE,0x06,0x60,0x03,0x0F,0x00,0x20,0x03,0x07,0x80,0x20,0x0F,0xFF,0xFF,0xFC,0x0F,0xFF,0xFF,0xFC,0x02,0x01,0xE0,0x60,0x03,0x30,0xF0,0x60,0x01,0xF0,0x7F,0xC0,0x01,0xF0,0x3F,0x80,0x00,0xF0,0x1F,0x00,0x00,0x00,0x00,0x00},//"$",4
N{0x00,0xFE,0x00,0x00,0x01,0xFF,0x00,0x00,0x03,0xFF,0x80,0x00,0x03,0x01,0x80,0x60,0x03,0x01,0x81,0xE0,0x03,0xFF,0x87,0xC0,0x01,0xFF,0x1F,0x00,0x00,0xFE,0xF8,0x00,0x00,0x03,0xFF,0x00,0x00,0x0F,0xFF,0xC0,0x00,0x7D,0xFF,0xE0,0x01,0xF1,0x80,0x60,0x03,0xC1,0x80,0x60,0x03,0x01,0xFF,0xE0,0x00,0x00,0xFF,0xC0,0x00,0x00,0x3F,0x00},//"%",5
N{0x00,0x00,0x1F,0x00,0x00,0x00,0x7F,0xC0,0x00,0xFC,0xFF,0xC0,0x01,0xFF,0xC0,0xE0,0x03,0xFF,0xE0,0x60,0x03,0x03,0xF8,0x20,0x02,0x06,0x7E,0x20,0x03,0xFE,0x1F,0x60,0x03,0xFC,0x07,0xC0,0x01,0xF1,0x03,0xC0,0x00,0x01,0x1F,0xE0,0x00,0x01,0xFC,0x60,0x00,0x01,0xE0,0x20,0x00,0x01,0x00,0x60,0x00,0x01,0x01,0xC0,0x00,0x00,0x01,0x80},//"&",6
N{0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x1C,0x60,0x00,0x00,0x1C,0x60,0x00,0x00,0x1F,0xC0,0x00,0x00,0x1F,0x80,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"'",7
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFF,0x00,0x00,0x7F,0xFF,0xC0,0x01,0xF8,0x07,0xE0,0x03,0xC0,0x00,0xF0,0x07,0x00,0x00,0x38,0x0C,0x00,0x00,0x0C,0x18,0x00,0x00,0x06,0x10,0x00,0x00,0x02},//"(",8
N{0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x02,0x18,0x00,0x00,0x06,0x0C,0x00,0x00,0x0C,0x07,0x00,0x00,0x38,0x03,0xC0,0x00,0xF0,0x01,0xF8,0x07,0xE0,0x00,0x7F,0xFF,0xC0,0x00,0x3F,0xFF,0x00,0x00,0x07,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//")",9
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x18,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x07,0x70,0x00,0x00,0x63,0x63,0x80,0x00,0xFF,0xFF,0x80,0x00,0xFF,0xFF,0x80,0x00,0x63,0x63,0x00,0x00,0x07,0x70,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x0E,0x38,0x00,0x00,0x0C,0x18,0x00},//"*",10
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFF,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00},//"+",11
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xE3,0x00,0x00,0x00,0xE3,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//",",12
N{0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00},//"-",13
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x01,0xE0,0x00,0x00,0x01,0xE0,0x00,0x00,0x01,0xE0,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//".",14
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0xF8,0x00,0x00,0x03,0xE0,0x00,0x00,0x0F,0x80,0x00,0x00,0x3E,0x00,0x00,0x00,0xF8,0x00,0x00,0x03,0xE0,0x00,0x00,0x0F,0x80,0x00,0x00,0x3E,0x00,0x00,0x00,0xF8,0x00,0x00,0x03,0xE0,0x00,0x00,0x0F,0x80,0x00,0x00,0x1E,0x00,0x00,0x00,0x18,0x00,0x00,0x00},//"/",15
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x7F,0xFF,0x00,0x00,0xFF,0xFF,0x80,0x01,0xF0,0x07,0xC0,0x03,0x80,0x00,0xE0,0x03,0x00,0x00,0x60,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x03,0x80,0x00,0xE0,0x01,0xE0,0x03,0xC0,0x00,0xFF,0xFF,0x80,0x00,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x00},//"0",16
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x20,0x00,0x80,0x00,0x60,0x01,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"1",17
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0xE0,0x00,0xF8,0x01,0xE0,0x01,0x98,0x03,0x60,0x03,0x00,0x06,0x60,0x02,0x00,0x0C,0x60,0x02,0x00,0x18,0x60,0x02,0x00,0x30,0x60,0x02,0x00,0x60,0x60,0x03,0x00,0xC0,0x60,0x03,0x83,0x80,0x60,0x01,0xFF,0x00,0xE0,0x01,0xFE,0x07,0xE0,0x00,0x7C,0x07,0x80,0x00,0x00,0x00,0x00},//"2",18
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x07,0x80,0x01,0xF0,0x07,0xC0,0x01,0xF0,0x07,0xC0,0x03,0x00,0x00,0x60,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x03,0x03,0x80,0x20,0x03,0x87,0x80,0x60,0x01,0xFE,0xC0,0xC0,0x01,0xFC,0xFF,0xC0,0x00,0x78,0x7F,0x80,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00},//"3",19
N{0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x78,0x00,0x00,0x01,0xC8,0x00,0x00,0x07,0x88,0x00,0x00,0x0E,0x08,0x10,0x00,0x3C,0x08,0x10,0x00,0x70,0x08,0x10,0x01,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xF0,0x03,0xFF,0xFF,0xF0,0x00,0x00,0x08,0x10,0x00,0x00,0x08,0x10,0x00,0x00,0x08,0x10},//"4",20
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x1F,0x87,0xC0,0x03,0xFF,0x86,0x60,0x03,0xE3,0x00,0x20,0x03,0x06,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x03,0x06,0x00,0x60,0x03,0x07,0x01,0xC0,0x03,0x03,0xFF,0xC0,0x03,0x01,0xFF,0x80,0x03,0x00,0x7E,0x00,0x00,0x00,0x00,0x00},//"5",21
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFC,0x00,0x00,0x3F,0xFF,0x00,0x00,0x7F,0xFF,0x80,0x00,0xF1,0xC3,0xC0,0x01,0x81,0x80,0xE0,0x03,0x03,0x00,0x60,0x03,0x02,0x00,0x20,0x02,0x02,0x00,0x20,0x02,0x02,0x00,0x20,0x02,0x03,0x00,0x60,0x03,0xC3,0x80,0xC0,0x01,0xC1,0xFF,0xC0,0x00,0xC0,0xFF,0x80,0x00,0x00,0x7E,0x00},//"6",22
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,0x03,0xF0,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x07,0xE0,0x03,0x00,0x3F,0xE0,0x03,0x01,0xFF,0xE0,0x03,0x07,0xC0,0x00,0x03,0x1E,0x00,0x00,0x03,0x78,0x00,0x00,0x03,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"7",23
N{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x78,0x3F,0x80,0x00,0xFC,0x7F,0xC0,0x01,0xFE,0xE0,0xC0,0x03,0x8F,0xC0,0x60,0x03,0x07,0x80,0x20,0x02,0x03,0x80,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0xC0,0x20,0x03,0x01,0xE0,0x60,0x03,0x87,0xF0,0xC0,0x01,0xFE,0x7F,0xC0,0x00,0xFC,0x3F,0x80,0x00,0x78,0x1F,0x00,0x00,0x00,0x00,0x00},//"8",24
N{0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0xFF,0x81,0xC0,0x01,0xFF,0xC1,0xC0,0x01,0xC0,0xE1,0xE0,0x03,0x00,0x60,0x20,0x02,0x00,0x20,0x20,0x02,0x00,0x20,0x20,0x02,0x00,0x20,0x60,0x02,0x00,0x60,0xE0,0x03,0x00,0xC1,0xC0,0x01,0xC1,0xCF,0x80,0x00,0xFF,0xFF,0x00,0x00,0x7F,0xFE,0x00,0x00,0x1F,0xF0,0x00,0x00,0x00,0x00,0x00},//"9",25
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xC0,0x00,0x07,0x81,0xE0,0x00,0x07,0x81,0xE0,0x00,0x07,0x81,0xE0,0x00,0x03,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//":",26
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x66,0x00,0x06,0x00,0x7E,0x00,0x06,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//";",27
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0xC0,0x00,0x00,0x03,0xE0,0x00,0x00,0x07,0x70,0x00,0x00,0x0E,0x38,0x00,0x00,0x1C,0x1C,0x00,0x00,0x38,0x0E,0x00,0x00,0x70,0x07,0x00,0x00,0xE0,0x03,0x80,0x01,0xC0,0x01,0xC0,0x03,0x00,0x00,0x60,0x06,0x00,0x00,0x30,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00},//"<",28
N{0x00,0x00,0x00,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00},//"=",29
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x06,0x00,0x00,0x30,0x03,0x00,0x00,0x60,0x01,0xC0,0x01,0xC0,0x00,0xE0,0x03,0x80,0x00,0x70,0x07,0x00,0x00,0x38,0x0E,0x00,0x00,0x1C,0x1C,0x00,0x00,0x0E,0x38,0x00,0x00,0x07,0x70,0x00,0x00,0x03,0xE0,0x00,0x00,0x01,0xC0,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00},//">",30
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x01,0xF8,0x00,0x00,0x03,0xF8,0x00,0x00,0x02,0x38,0x00,0x00,0x06,0x00,0x00,0xC0,0x04,0x00,0x79,0xE0,0x04,0x00,0xF9,0xE0,0x04,0x01,0x81,0xE0,0x04,0x03,0x00,0xC0,0x06,0x03,0x00,0x00,0x03,0x06,0x00,0x00,0x03,0xFE,0x00,0x00,0x01,0xFC,0x00,0x00,0x00,0xF8,0x00,0x00},//"?",31
N{0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0x7F,0xFF,0x80,0x00,0xF0,0x07,0xC0,0x01,0xC1,0xF8,0xC0,0x03,0x07,0xFC,0x60,0x03,0x1F,0xFC,0x20,0x02,0x3E,0x0C,0x20,0x02,0x30,0x38,0x20,0x02,0x3F,0xFC,0x20,0x03,0x3F,0xFC,0x60,0x01,0xBF,0x0C,0xC0,0x01,0xE0,0x3D,0xC0,0x00,0xFF,0xF3,0x80,0x00,0x1F,0xC2,0x00},//"@",32
N{0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x60,0x00,0x00,0x03,0xE0,0x00,0x00,0x3F,0xE0,0x00,0x03,0xFE,0x20,0x00,0x3F,0xE0,0x20,0x03,0xFE,0x20,0x00,0x03,0xE0,0x20,0x00,0x07,0xFC,0x20,0x00,0x07,0xFF,0xE0,0x00,0x00,0x3F,0xFE,0x20,0x00,0x03,0xFF,0xE0,0x00,0x00,0x3F,0xE0,0x00,0x00,0x01,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20},//"A",33
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x03,0x03,0x00,0x20,0x03,0x87,0x80,0x60,0x01,0xFE,0xC0,0xE0,0x01,0xFC,0xFF,0xC0,0x00,0xF8,0x7F,0x80,0x00,0x00,0x1F,0x00},//"B",34
N{0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFF,0x00,0x00,0x7F,0xFF,0x80,0x00,0xF0,0x07,0xC0,0x01,0xC0,0x00,0xC0,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x01,0x80,0x00,0xC0,0x03,0xC0,0x01,0xC0,0x03,0xF0,0x07,0x80,0x00,0x30,0x06,0x00},//"C",35
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x60,0x01,0x80,0x00,0xC0,0x01,0xF0,0x07,0xC0,0x00,0xFF,0xFF,0x80,0x00,0x7F,0xFE,0x00,0x00,0x0F,0xF8,0x00},//"D",36
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x03,0x80,0x20,0x02,0x0F,0xE0,0x20,0x03,0x0F,0xE0,0x60,0x03,0xC0,0x00,0xE0,0x03,0xE0,0x03,0xE0,0x00,0x60,0x03,0x00},//"E",37
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x20,0x02,0x01,0x00,0x00,0x02,0x01,0x00,0x00,0x02,0x01,0x00,0x00,0x02,0x03,0x80,0x00,0x03,0x0F,0xE0,0x00,0x03,0x0F,0xE0,0x00,0x03,0xC0,0x00,0x00,0x03,0xE0,0x00,0x00},//"F",38
N{0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0x7F,0xFF,0x80,0x01,0xF0,0x07,0xC0,0x01,0xC0,0x01,0xC0,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x20,0x20,0x01,0x00,0x20,0x60,0x03,0xC0,0x3F,0xC0,0x03,0xF0,0x3F,0x80,0x00,0x30,0x3F,0x80,0x00,0x00,0x20,0x00},//"G",39
N{0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20},//"H",40
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"I",41
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x0F,0x02,0x00,0x00,0x01,0x02,0x00,0x00,0x01,0x02,0x00,0x00,0x03,0x02,0x00,0x00,0x07,0x03,0xFF,0xFF,0xFE,0x03,0xFF,0xFF,0xFC,0x03,0xFF,0xFF,0xF8,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"J",42
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0xC0,0x20,0x02,0x07,0x80,0x20,0x00,0x0F,0xE0,0x00,0x00,0x3F,0xF8,0x00,0x02,0x70,0xFE,0x20,0x03,0xE0,0x3F,0x20,0x03,0x80,0x0F,0xE0,0x03,0x00,0x03,0xE0,0x02,0x00,0x00,0xE0,0x02,0x00,0x00,0x20},//"K",43
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0xE0,0x00,0x00,0x03,0xE0,0x00,0x00,0x03,0x00},//"L",44
N{0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0x00,0x20,0x03,0xFF,0xF0,0x20,0x00,0x1F,0xFF,0x80,0x00,0x01,0xFF,0xE0,0x00,0x00,0x1F,0xE0,0x00,0x03,0xFE,0x00,0x00,0x3F,0xE0,0x20,0x03,0xFE,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20},//"M",45
N{0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xF0,0x00,0x20,0x03,0xFC,0x00,0x20,0x00,0xFF,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x07,0xF0,0x00,0x00,0x01,0xFC,0x00,0x02,0x00,0x7F,0x80,0x02,0x00,0x1F,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"N",46
N{0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x3F,0xFE,0x00,0x00,0xFF,0xFF,0x80,0x01,0xF0,0x07,0xC0,0x01,0x80,0x00,0xC0,0x03,0x00,0x00,0x60,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x00,0x00,0x60,0x01,0x80,0x00,0xC0,0x01,0xF0,0x03,0xC0,0x00,0xFF,0xFF,0x80,0x00,0x3F,0xFE,0x00,0x00,0x0F,0xF8,0x00},//"O",47
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x20,0x02,0x00,0x80,0x00,0x02,0x00,0x80,0x00,0x02,0x00,0x80,0x00,0x03,0x01,0x80,0x00,0x03,0x83,0x80,0x00,0x01,0xFF,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x7C,0x00,0x00},//"P",48
N{0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x00,0x00,0x7F,0xFF,0x00,0x00,0xFF,0xFF,0x80,0x01,0xF0,0x03,0xC0,0x01,0x80,0x07,0xC0,0x03,0x00,0x06,0x60,0x02,0x00,0x04,0x20,0x02,0x00,0x06,0x20,0x02,0x00,0x07,0xE0,0x03,0x00,0x03,0xF8,0x01,0x80,0x00,0xFC,0x01,0xE0,0x03,0xDC,0x00,0xFF,0xFF,0x8C,0x00,0x3F,0xFF,0x1C,0x00,0x0F,0xFC,0x18},//"Q",49
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x01,0x00,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0xE0,0x00,0x02,0x01,0xFC,0x00,0x03,0x03,0xFF,0x80,0x03,0x87,0x3F,0xE0,0x01,0xFE,0x07,0xE0,0x01,0xFC,0x00,0xE0,0x00,0xF8,0x00,0x20,0x00,0x00,0x00,0x20},//"R",50
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x06,0x00,0x00,0xFE,0x07,0xE0,0x01,0xFE,0x01,0xE0,0x03,0x87,0x00,0xC0,0x03,0x03,0x00,0x60,0x02,0x03,0x80,0x20,0x02,0x01,0x80,0x20,0x02,0x01,0xC0,0x20,0x02,0x01,0xC0,0x20,0x03,0x00,0xE0,0x60,0x01,0x80,0xF0,0xE0,0x03,0xE0,0x7F,0xC0,0x03,0xE0,0x3F,0x80,0x00,0x00,0x1F,0x00},//"S",51
N{0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x03,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x03,0xFF,0xFF,0xE0,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x03,0xE0,0x00,0x00,0x00,0xE0,0x00,0x00},//"T",52
N{0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xFF,0xFF,0x00,0x03,0xFF,0xFF,0xC0,0x03,0xFF,0xFF,0xC0,0x02,0x00,0x00,0x60,0x02,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x02,0x00,0x00,0x60,0x02,0x00,0x00,0xC0,0x03,0xFF,0xFF,0x80,0x03,0xFF,0xFF,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"U",53
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xFC,0x00,0x00,0x03,0xFF,0xC0,0x00,0x02,0x3F,0xF8,0x00,0x00,0x03,0xFF,0x80,0x00,0x00,0x7F,0xE0,0x00,0x00,0x07,0xE0,0x00,0x00,0x7F,0x80,0x02,0x03,0xF8,0x00,0x02,0x3F,0xC0,0x00,0x03,0xFC,0x00,0x00,0x03,0xC0,0x00,0x00,0x02,0x00,0x00,0x00},//"V",54
N{0x02,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xFF,0x80,0x00,0x03,0xFF,0xFE,0x00,0x02,0x3F,0xFF,0xE0,0x02,0x00,0x7F,0xE0,0x02,0x00,0xFF,0x00,0x03,0xEF,0xF0,0x00,0x03,0xFF,0x80,0x00,0x03,0xFF,0xFE,0x00,0x02,0x0F,0xFF,0xE0,0x00,0x00,0x3F,0xE0,0x02,0x07,0xFF,0x00,0x03,0xFF,0xE0,0x00,0x03,0xF8,0x00,0x00,0x03,0x00,0x00,0x00},//"W",55
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0x80,0x00,0xE0,0x03,0xF0,0x03,0xE0,0x03,0xFC,0x0F,0x20,0x02,0xFF,0x3C,0x20,0x02,0x1F,0xF0,0x00,0x00,0x07,0xF0,0x00,0x02,0x1F,0xFC,0x00,0x02,0x78,0x7F,0x20,0x03,0xE0,0x1F,0xE0,0x03,0x80,0x03,0xE0,0x02,0x00,0x00,0xE0,0x02,0x00,0x00,0x20,0x00,0x00,0x00,0x20},//"X",56
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x03,0xF8,0x00,0x00,0x03,0xFE,0x00,0x20,0x02,0x3F,0xC0,0x20,0x02,0x0F,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x02,0x1F,0x80,0x20,0x02,0x7C,0x00,0x20,0x03,0xF0,0x00,0x00,0x03,0x80,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00},//"Y",57
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x60,0x00,0xE0,0x03,0xE0,0x03,0xE0,0x03,0x80,0x0F,0xE0,0x03,0x00,0x3F,0xA0,0x02,0x00,0xFE,0x20,0x02,0x03,0xF8,0x20,0x02,0x0F,0xE0,0x20,0x02,0x3F,0x80,0x20,0x02,0x7E,0x00,0x20,0x03,0xF8,0x00,0x60,0x03,0xE0,0x00,0xE0,0x03,0x80,0x03,0xE0,0x02,0x00,0x03,0x00,0x00,0x00,0x00,0x00},//"Z",58
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFC,0x1F,0xFF,0xFF,0xFC,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x00},//"[",59
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x07,0xC0,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x03,0xF0,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x1F,0x80,0x00,0x00,0x07,0xF0,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00},//"\",60
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x10,0x00,0x00,0x04,0x1F,0xFF,0xFF,0xFC,0x1F,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"]",61
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"^",62
N{0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01},//"_",63
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"`",64
N{0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x00,0x01,0x8F,0xC0,0x00,0x03,0x8F,0xE0,0x00,0x07,0x9C,0x60,0x00,0x06,0x18,0x20,0x00,0x04,0x10,0x20,0x00,0x04,0x30,0x20,0x00,0x04,0x20,0x60,0x00,0x06,0x20,0x40,0x00,0x07,0xFF,0xC0,0x00,0x03,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0xC0},//"a",65
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xC0,0x00,0x03,0x80,0xE0,0x00,0x02,0x00,0x60,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x60,0x00,0x07,0x00,0xC0,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0xFE,0x00},//"b",66
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0xFF,0xC0,0x00,0x03,0x81,0xC0,0x00,0x06,0x00,0x60,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x07,0xC0,0x60,0x00,0x03,0xC0,0xC0,0x00,0x01,0xC3,0x80,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00},//"c",67
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0xFF,0xC0,0x00,0x07,0x80,0xE0,0x00,0x06,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x02,0x04,0x00,0x60,0x02,0x06,0x00,0xC0,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40},//"d",68
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0xFF,0xC0,0x00,0x03,0x11,0xC0,0x00,0x06,0x10,0x60,0x00,0x04,0x10,0x60,0x00,0x04,0x10,0x20,0x00,0x04,0x10,0x20,0x00,0x06,0x10,0x20,0x00,0x07,0x10,0x60,0x00,0x03,0xF0,0xC0,0x00,0x01,0xF1,0xC0,0x00,0x00,0x71,0x00,0x00,0x00,0x00,0x00},//"e",69
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x7F,0xFF,0xE0,0x01,0xFF,0xFF,0xE0,0x01,0xFF,0xFF,0xE0,0x03,0x04,0x00,0x20,0x03,0x04,0x00,0x20,0x02,0x04,0x00,0x20,0x02,0x04,0x00,0x20,0x02,0x04,0x00,0x00,0x03,0xC0,0x00,0x00,0x01,0xC0,0x00,0x00},//"f",70
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x00,0xE3,0x3E,0x00,0x03,0xFF,0xFE,0x00,0x03,0xFF,0xC3,0x00,0x06,0x0C,0xC3,0x00,0x04,0x04,0xC1,0x00,0x04,0x04,0xC1,0x00,0x04,0x04,0xC1,0x00,0x06,0x0C,0xC1,0x00,0x07,0xFC,0xC3,0x00,0x07,0xF8,0xE3,0x00,0x07,0xF0,0x7E,0x00,0x06,0x00,0x7E,0x00,0x06,0x00,0x3C},//"g",71
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x03,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20},//"h",72
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x03,0x87,0xFF,0xE0,0x03,0x8F,0xFF,0xE0,0x03,0x8F,0xFF,0xE0,0x03,0x80,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"i",73
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x03,0x00,0x04,0x00,0x07,0x03,0x87,0xFF,0xFE,0x03,0x8F,0xFF,0xFC,0x03,0x8F,0xFF,0xF8,0x03,0x80,0x00,0x00,0x00,0x00,0x00,0x00},//"j",74
N{0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x00,0x18,0x20,0x00,0x00,0x30,0x20,0x00,0x00,0xFC,0x00,0x00,0x05,0xFE,0x00,0x00,0x07,0x8F,0xA0,0x00,0x07,0x07,0xE0,0x00,0x06,0x01,0xE0,0x00,0x04,0x00,0xE0,0x00,0x04,0x00,0x20,0x00,0x00,0x00,0x20},//"k",75
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x02,0x00,0x00,0x20,0x03,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x07,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"l",76
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x00,0x00,0x20},//"m",77
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x03,0x00,0x20,0x00,0x02,0x00,0x20,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x07,0xFF,0xE0,0x00,0x03,0xFF,0xE0,0x00,0x01,0xFF,0xE0,0x00,0x00,0x00,0x20},//"n",78
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0xFF,0x80,0x00,0x03,0xFF,0xC0,0x00,0x03,0x81,0xC0,0x00,0x06,0x00,0x60,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x06,0x00,0x60,0x00,0x03,0x81,0xC0,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0x7E,0x00},//"o",79
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x01,0x00,0x07,0xFF,0xFF,0x00,0x0F,0xFF,0xFF,0x00,0x0F,0xFF,0xFF,0x00,0x03,0x00,0xC1,0x00,0x06,0x00,0x61,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x60,0x00,0x07,0x01,0xC0,0x00,0x03,0xFF,0xC0,0x00,0x01,0xFF,0x80,0x00,0x00,0x7E,0x00},//"p",80
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x01,0xFF,0x80,0x00,0x03,0xFF,0xC0,0x00,0x03,0x80,0xE0,0x00,0x06,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x06,0x00,0x61,0x00,0x03,0x00,0xC1,0x00,0x03,0xFF,0xFF,0x00,0x07,0xFF,0xFF,0x00,0x07,0xFF,0xFF,0x00,0x00,0x00,0x01},//"q",81
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x01,0xC0,0x20,0x00,0x03,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x06,0x00,0x20,0x00,0x04,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x03,0x00,0x00},//"r",82
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x01,0xC3,0xE0,0x00,0x03,0xE0,0xE0,0x00,0x07,0xF0,0x60,0x00,0x06,0x30,0x20,0x00,0x04,0x38,0x20,0x00,0x04,0x18,0x20,0x00,0x04,0x18,0x20,0x00,0x04,0x1C,0x20,0x00,0x06,0x0C,0x60,0x00,0x03,0x0F,0xE0,0x00,0x07,0x87,0xC0,0x00,0x07,0x83,0x80,0x00,0x00,0x00,0x00},//"s",83
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x1F,0xFF,0x80,0x00,0xFF,0xFF,0xC0,0x00,0xFF,0xFF,0xE0,0x00,0x04,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x60,0x00,0x04,0x01,0xC0,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00},//"t",84
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x0F,0xFF,0xC0,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x04,0x00,0x60,0x00,0x04,0x00,0xC0,0x00,0x07,0xFF,0xE0,0x00,0x0F,0xFF,0xE0,0x00,0x0F,0xFF,0xC0,0x00,0x00,0x00,0x40},//"u",85
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x07,0xF0,0x00,0x00,0x07,0xFE,0x00,0x00,0x04,0xFF,0xC0,0x00,0x04,0x1F,0xE0,0x00,0x00,0x03,0xE0,0x00,0x00,0x1F,0x80,0x00,0x04,0x7C,0x00,0x00,0x07,0xE0,0x00,0x00,0x07,0x80,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00},//"v",86
N{0x00,0x04,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0xC0,0x00,0x00,0x07,0xFC,0x00,0x00,0x07,0xFF,0x80,0x00,0x04,0x3F,0xE0,0x00,0x04,0x0F,0xE0,0x00,0x06,0xFF,0x80,0x00,0x07,0xF0,0x00,0x00,0x07,0xFF,0x80,0x00,0x07,0xFF,0xE0,0x00,0x04,0x0F,0xE0,0x00,0x04,0x3F,0x80,0x00,0x07,0xFC,0x00,0x00,0x07,0xC0,0x00,0x00,0x06,0x00,0x00},//"w",87
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x04,0x00,0x20,0x00,0x04,0x00,0x60,0x00,0x07,0x00,0xE0,0x00,0x07,0x83,0xE0,0x00,0x07,0xE7,0x20,0x00,0x07,0xFE,0x00,0x00,0x04,0xFC,0x00,0x00,0x04,0x7E,0x20,0x00,0x05,0xDF,0xA0,0x00,0x07,0x87,0xE0,0x00,0x06,0x01,0xE0,0x00,0x04,0x00,0x60,0x00,0x04,0x00,0x20,0x00,0x00,0x00,0x20},//"x",88
N{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x03,0x00,0x07,0x00,0x03,0x00,0x07,0xE0,0x03,0x00,0x07,0xF8,0x01,0x00,0x04,0xFF,0x03,0x00,0x04,0x1F,0xFE,0x00,0x00,0x07,0xFC,0x00,0x00,0x07,0xE0,0x00,0x04,0x3F,0x00,0x00,0x07,0xF8,0x00,0x00,0x07,0xC0,0x00,0x00,0x06,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00},//"y",89
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x60,0x00,0x07,0x80,0xE0,0x00,0x06,0x03,0xE0,0x00,0x04,0x07,0xE0,0x00,0x04,0x0F,0xA0,0x00,0x04,0x3E,0x20,0x00,0x04,0x7C,0x20,0x00,0x05,0xF0,0x20,0x00,0x07,0xE0,0x20,0x00,0x07,0x80,0x60,0x00,0x07,0x00,0xE0,0x00,0x04,0x03,0xE0,0x00,0x00,0x03,0x80,0x00,0x00,0x00,0x00},//"z",90
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0xC0,0x00,0x07,0xFF,0x7F,0xF8,0x0F,0xFE,0x3F,0xFC,0x18,0x00,0x00,0x06,0x10,0x00,0x00,0x02,0x10,0x00,0x00,0x02,0x00,0x00,0x00,0x00},//"{",91
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"|",92
N{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x02,0x10,0x00,0x00,0x02,0x18,0x00,0x00,0x06,0x0F,0xFE,0x3F,0xFC,0x07,0xFF,0x7F,0xF8,0x00,0x01,0xC0,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"}",93
N{0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x18,0x00,0x00,0x00},//"~",94
N
N};
N#endif
N
N
N#endif
L 3 "devices\jpstm32_lcd.c" 2
N#include "jpstm32_delay.h"
L 1 ".\core\jpstm32_delay.h" 1
N/*************************************************************
N * File name: jpstm32_delay.h
N * Author: Duke An
N * Version: 0.1
N * Date: 20140617
N * Description: 系统延时相关定义
N * Copyright @ 2013 by Briup Technology,Inc. All rights Reserved.
N *************************************************************/
N#ifndef __JPSTM32_DELAY_H__
N#define	__JPSTM32_DELAY_H__
N
N#include "jpstm32_common.h"
N
Nextern void _delay_init(u8 SYSCLK);
Nextern void _delay_ms(u16 ms);
Nextern void _delay_us(u32 us);
N
N#endif
L 4 "devices\jpstm32_lcd.c" 2
N#include "jpstm32_usart.h"
L 1 ".\core\jpstm32_usart.h" 1
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * File name: jpstm32_usart.c
N * Author: Duke An
N * Version: 0.1
N * Date: 2014-06-17
N * Description: USART灯操作实现
N * Copyright @ 2013 by Briup Technology,Inc. All rights Reserved.
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N#ifndef __JPSTM32_USART_H__
N#define __JPSTM32_USART_H__
N
N#include "jpstm32_common.h"
N#include "jpstm32_nvic.h"
L 1 ".\core\jpstm32_nvic.h" 1
N/*************************************************************
N * File name: jpstm32_nvic.h
N * Author: Duke An
N * Version: 0.1
N * Date: 20140617
N * Description: 系统中断设置
N * Copyright @ 2013 by Briup Technology,Inc. All rights Reserved.
N *************************************************************/
N
N#ifndef __JPSTM32_NVIC_H__
N#define __JPSTM32_NVIC_H__
N
N#include "jpstm32_common.h"
N
N/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N * Function:	select_nvic_vector
N * Description: 设置系统NVIC向量表的存储位置
N * Input: 
N *	>NVIC_VectTab, 向量表存储位置
N *  >Offset, 偏移量
N * Output: NULL
N * Return: NULL
N * Others: NULL
N * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
Nextern void select_nvic_vector(u32 NVIC_VectTab, u32 Offset);
N
Nextern bool nvic_set_enable(u8 Channel);
Nextern bool nvic_clear_enable(u8 Channel);
Nextern bool nvic_set_pending(u8 Channel);
Nextern bool nvic_clear_pending(u8 Channel);
Nextern bool nvic_get_active(u8 Channel);
Nextern bool nvic_set_group(u8 group);
Nextern bool nvic_set_priority(u8 Channel, u8 PreemptionPriority, u8 SubPriority);
Nextern vu32 nvic_get_priority(void);
N
Nextern bool register_nvic(u8 nvic_Group, u8 nvic_PreemptionPriority, u8 nvic_SubPriority, u8 nvic_Channel);
N
N
N#endif
L 14 ".\core\jpstm32_usart.h" 2
N#include "stdio.h"
L 1 "D:\Program Files\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030024
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 15 ".\core\jpstm32_usart.h" 2
N
N
N
N#define USART_REC_LEN  		256  	//定义最大接收字节数 256
N#define EN_USART1_RX 			1		//使能（1）/禁止（0）串口1接收
N#define RX_MASK						0x00FF
N//接收缓冲区状态标记
N#define	RX_BUF_F					0x01
N#define RX_BUF_E					0x02
Ntypedef struct {
N	s8	rx_buf[USART_REC_LEN];
X	s8	rx_buf[256];
N	u16	rx_seek;
N	u16	rx_size;
N	u8	rx_stat;
N}USARTypDef;
N	  	
N//如果想串口中断接收，请不要注释以下宏定义
Nvoid usart1_init(u32 pclk2,u32 bound);
N//获取一个字节的数据
Ns8	usart1_getc(void);
N//获取一个定长的字符串
Nu8 usart1_gets(s8* buf, u16 len);
N
N
N#endif
L 5 "devices\jpstm32_lcd.c" 2
N#include "stdio.h"
N
N/* **************************************************
N * ㄥ
N * *************************************************/
N
Nu16 POINT_COLOR=0x0000;	//荤棰
Nu16 BACK_COLOR=0xFFFF;  // 
N
N//璁惧淇℃
NLcdDev	Lcd_Dev;
N
N/* **************************************************
N * 芥板０
N * *************************************************/
N//LCD16浣浠
Nstatic void lcdWriteCmd(u16 cmd);
N//LCD16浣版
Nstatic void lcdWriteData(u16 data);
N//璇诲LCD版
Nstatic u16 lcdReadData(void);
N//瀹瀵瀛
Nstatic void lcdWriteReg(u8 lcd_reg, u16 reg_val);
N//璇诲瀹瀵瀛
Nstatic u16 lcdReadReg(u8 lcd_reg);
N//寮濮GRAM
Nstatic void lcdWriteMem(void);
N//璁剧疆璁惧
Nstatic void lcdSetParam(void);
N/* **************************************************
N * 渚缁ㄦ风芥
N * **************************************************/
N 
N 
N//lcd濮
Nvoid lcdInit(void)
N{
N	/* ********************************
N	 * I/O绔ｉ缃
N	 * *******************************/
N	//I/O绔ｅ濮
N	RCC->AHBENR |= 1<<8;
X	((RCC_TypeDef *) ((((u32)0x40000000) + 0x20000) + 0x1000))->AHBENR |= 1<<8;
N	//绔B,D,E,G堕浣胯
N	RCC->APB2ENR |= (1<<3)|(1<<5)|(1<<6)|(1<<8);
X	((RCC_TypeDef *) ((((u32)0x40000000) + 0x20000) + 0x1000))->APB2ENR |= (1<<3)|(1<<5)|(1<<6)|(1<<8);
N	//PB0 ㄦ借猴LCDу
N	GPIOB->CRL &= 0xFFFFFFF0;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0C00))->CRL &= 0xFFFFFFF0;
N	GPIOB->CRL |= 0x00000003;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0C00))->CRL |= 0x00000003;
N	//PORTD 澶ㄦㄦ借
N	GPIOD->CRH &= 0x00FFF000;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1400))->CRH &= 0x00FFF000;
N	GPIOD->CRH |= 0xBB000BBB;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1400))->CRH |= 0xBB000BBB;
N	GPIOD->CRL &= 0XFF00FF00;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1400))->CRL &= 0XFF00FF00;
N	GPIOD->CRL |= 0X00BB00BB;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1400))->CRL |= 0X00BB00BB;
N	//PORTE 澶ㄦㄦ借
N	GPIOE->CRH &= 0X00000000;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1800))->CRH &= 0X00000000;
N	GPIOE->CRH |= 0XBBBBBBBB; 
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1800))->CRH |= 0XBBBBBBBB; 
N	GPIOE->CRL &= 0X0FFFFFFF;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1800))->CRL &= 0X0FFFFFFF;
N	GPIOE->CRL |= 0XB0000000;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x1800))->CRL |= 0XB0000000;
N	//PORTG 澶ㄦㄦ借
N	GPIOG->CRH &= 0XFFF0FFFF;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2000))->CRH &= 0XFFF0FFFF;
N	GPIOG->CRH |= 0X000B0000; 
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2000))->CRH |= 0X000B0000; 
N	GPIOG->CRL &= 0XFFFFFFF0;	//PG0->RS
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2000))->CRL &= 0XFFFFFFF0;	
N	GPIOG->CRL |= 0X0000000B;
X	((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2000))->CRL |= 0X0000000B;
N	/* ********************************
N	 * FSMC缃
N	 * *******************************/
N	//瀵瀛ㄦ
N	//Bank1辨NE1~4锛姣涓绔ｉ芥涓涓BCR+TCR锛浠ュ辨8涓瀵瀛
N	//JPIOT-STM32-V1浣跨ㄧNE4锛冲瑰BTCR[6]BTCR[7]
N	FSMC_Bank1->BTCR[6] = 0x00000000;	//BCR
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[6] = 0x00000000;	
N	FSMC_Bank1->BTCR[7] = 0x00000000;	//BTR
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[7] = 0x00000000;	
N	FSMC_Bank1E->BWTR[6] = 0x00000000;
X	((FSMC_Bank1E_TypeDef *) (((u32)0xA0000000) + 0x0104))->BWTR[6] = 0x00000000;
N	//BCR 缃	寮姝ユā寮
N	FSMC_Bank1->BTCR[6] |= 1<<12;	//瀛ㄥ  浣胯
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[6] |= 1<<12;	
N	FSMC_Bank1->BTCR[6] |= 1<<14;	//璇  浣跨ㄤ跺
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[6] |= 1<<14;	
N	FSMC_Bank1->BTCR[6] |= 1<<4;	//瀛ㄦ版瀹藉害涓16浣
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[6] |= 1<<4;	
N	//BTR 缃锛璇 跺缃
N	FSMC_Bank1->BTCR[7] |= 0<<28;	//ㄦā寮A
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[7] |= 0<<28;	
N	FSMC_Bank1->BTCR[7] |= 1<<0;	//板寤虹堕翠负2*HCLK
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[7] |= 1<<0;	
N	FSMC_Bank1->BTCR[7] |= 0x8<<8;	//版淇瀛堕翠负16*HCLK
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[7] |= 0x8<<8;	
N	// у
N	FSMC_Bank1E->BWTR[6] |= 0<<28;	//MODE A
X	((FSMC_Bank1E_TypeDef *) (((u32)0xA0000000) + 0x0104))->BWTR[6] |= 0<<28;	
N	FSMC_Bank1E->BWTR[6] |= 0<<0;	//板寤虹堕翠负1*HCLK
X	((FSMC_Bank1E_TypeDef *) (((u32)0xA0000000) + 0x0104))->BWTR[6] |= 0<<0;	
N	//娑叉堕┍IC淇″疯茶冲瑕50ns锛72MHz/4=24MHz=55ns, 浠
N	FSMC_Bank1E->BWTR[6] |= 3<<8;	//版淇瀛堕翠负4*HCLK
X	((FSMC_Bank1E_TypeDef *) (((u32)0xA0000000) + 0x0104))->BWTR[6] |= 3<<8;	
N	//浣胯Bank1绗
N	FSMC_Bank1->BTCR[6] |= 1<<0;	//浣胯Bank1绗
X	((FSMC_Bank1_TypeDef *) (((u32)0xA0000000) + 0x0000))->BTCR[6] |= 1<<0;	
N	_delay_ms(50);
N	//ㄦ堕
N	lcdWriteReg(0x0000, 0x0001);
N	_delay_ms(50);
N#if 1
N	//峰ID
N	Lcd_Dev.dev_no = lcdReadReg(0x0000);
N	if(Lcd_Dev.dev_no<0xFF||Lcd_Dev.dev_no==0xFFFF){
N		lcdWriteCmd(0xD3);
N		lcdReadData();
N		lcdReadData();
N		Lcd_Dev.dev_no = lcdReadData();
N		Lcd_Dev.dev_no <<= 8;
N		Lcd_Dev.dev_no |= lcdReadData();
N	}
N	printf("LCD ID: %x\r\n", Lcd_Dev.dev_no);
N#endif
N	/* ********************************
N	 * LCD9486伴缃
N	 * *******************************/
N#if 1
N	/* *************************************************
N	 * Normal Display Mode ON
N	 * This command returns the display to normal mode. 
N	 * Normal display mode on means Partial mode off and 
N	 * Scroll mode off.
N	 * *************************************************/
N
N	lcdWriteCmd(0x0013);
N	/* ************************************************* 
N	 * Frame Rate Control (In Normal Mode/Full Colors)
N	 * args:
N	 *	1.Sets the frame frequency of full normal mode.
N	 *	2.Set the division ratio for internal clocks when
N	 *	Normal Mode
N	 * *************************************************/
N	lcdWriteCmd(0x00B1);
N	lcdWriteData(0x00A0);
N	lcdWriteData(0x0000);
N	//Display Inversion Control
N	lcdWriteCmd(0x00B4);
N	lcdWriteData(0x0000);
N	//璁剧疆剧ず哄杈圭
N	lcdWriteCmd(0x002A);			//set_column_address
N	lcdWriteData(0x0000);
N	lcdWriteData(0x0000);
N	lcdWriteData(0x0001);
N	lcdWriteData(0x00DF);//480
N	//璁剧疆剧ず鸿杈圭
N	lcdWriteCmd(0x002B);			//set_page_address
N	lcdWriteData(0x0000);
N	lcdWriteData(0x0000);
N	lcdWriteData(0x0001);
N	lcdWriteData(0x003F);//320
N	//Tearing Effect Line ON
N	lcdWriteCmd(0x0035);
N	lcdWriteData(0x0000);
N	//Memory Access Control
N	lcdWriteCmd(0x0036);
N	lcdWriteData(0x0030);
N	//PGAMCTRL(Positive Gamma Control)
N	//璁剧疆TFT灞骞板害姝ｅ靛璋翠冀椹
N	lcdWriteCmd(0xE0);
N	lcdWriteData(0x09);
N	lcdWriteData(0x0a);
N	lcdWriteData(0x0e);
N	lcdWriteData(0x0d);
N	lcdWriteData(0x07);
N	lcdWriteData(0x18);
N	lcdWriteData(0x0d);
N	lcdWriteData(0x0d);
N	lcdWriteData(0x0e);
N	lcdWriteData(0x04);
N	lcdWriteData(0x05);
N	lcdWriteData(0x06);
N	lcdWriteData(0x0e);
N	lcdWriteData(0x25);
N	lcdWriteData(0x22);
N	//NGAMCTRL (Negative Gamma Correction)
N	//璁剧疆TFT灞骞板害璐靛璋翠冀椹
N	lcdWriteCmd(0XE1);
N	lcdWriteData(0x1F);
N	lcdWriteData(0x3F);
N	lcdWriteData(0x3F);
N	lcdWriteData(0x0F);
N	lcdWriteData(0x1F);
N	lcdWriteData(0x0F);
N	lcdWriteData(0x46);
N	lcdWriteData(0x49);
N	lcdWriteData(0x31);
N	lcdWriteData(0x05);
N	lcdWriteData(0x09);
N	lcdWriteData(0x03);
N	lcdWriteData(0x1C);
N	lcdWriteData(0x1A);
N	lcdWriteData(0x00);
N	//Interface Pixel Format绱煎
N	lcdWriteCmd(0x003A);   //set_pixel_format
N	lcdWriteData(0x0055);
N	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N	 * Write Tear Scan Line 
N	 * This command turns on the display Tearing Effect output signal 
N	 * on the TE signal line when the display reaches line N. The 
N	 * TE signal is not affected by changing Memory Access Control 
N	 * bit B4. The Tearing Effect Line On has one parameter that 
N	 * describes the Tearing Effect Output Line mode. The Tearing 
N	 * Effect Output line consists of V-Blanking information only.
N	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N	lcdWriteCmd(0x0044);
N	lcdWriteData(0x0000);
N	lcdWriteData(0x0001);
N	//turn off the sleep mode
N	lcdWriteCmd(0x0011);
N	_delay_ms(150);
N	//NV Memory Write
N	lcdWriteCmd(0x00D0);	
N	lcdWriteData(0x0007);
N	lcdWriteData(0x0007);
N	//NV Memory Protection Key
N	lcdWriteCmd(0x00D1);
N	lcdWriteData(0x0003);
N	lcdWriteData(0x0052);
N	lcdWriteData(0x0010);
N	//NV Memory Status Read
N	lcdWriteCmd(0x00D2);
N	lcdWriteData(0x0003);
N	lcdWriteData(0x0024);
N	lcdWriteCmd(0x0020);
N	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N	 * Interface Mode Control 
N	 * Sets the operation status of the display interface.
N	 * The setting becomes effective as soon as the command is received.
N	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N	lcdWriteCmd(0x00B0);//{setc, [107], W, 0x000B0}
N	lcdWriteData(0x0000);//{setp, [104], W, 0x00000}
N	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
N	 * Display On 
N	 * This command causes ILI9486L to start displaying the image 
N	 * data on the display device. The frame memory contents remain
N	 * unchanged. No status bits are changed.
N	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
N	lcdWriteCmd(0x0029);		//set_display_on
N	_delay_ms(10);
N#endif
N	lcdSetParam();			//璁剧疆LCD	 
N	BLIGHT = BLIGHT_ON;		//逛寒	 
X	*((vu32*)(((vu32)(&((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0C00))->ODR)&0xF0000000)+0x2000000 +(((vu32)(&((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0C00))->ODR)&0xFFFFF)<<5) + (0<<2))) = 1;		
N	lcdClear((u16)GREEN);	//娓灞
X	lcdClear((u16)0x07E0);	
N}
N
Nvoid lcd_write_cmd(void)
N{
N	lcdWriteMem();
N}
N
N//娓灞锛ㄥ濉
Nvoid lcdClear(u16 color)
N{
N	u32 index = 0;
N	u32	total = 0;
N	u8	range = 5;
N	total = Lcd_Dev.width*Lcd_Dev.height;
N#if 0
S	//lcdDisplayOff();
S	lcdSetWindow(0, 0, Lcd_Dev.width-1, Lcd_Dev.height);
S	for(index=0; index<total; index++){
S		LCD_ADDR->lcd_data = color;
S	}
S	//lcdDisplayOn();
N#endif 
N
N#if 1	//琛濉浠ユ楂婚㈠㈢娴锛璨浼间琛
N	//lcdDisplayOff();
N	
N
N#if LCD_VIEW_MODE == LCD_HOR_MODE
X#if 0 == 1
S	for(index=0; index<320/range; index++){
S		if(index%2 == 0){
S			lcdSetWindow(0, index*range, 480-1, index*range+range);
S			for(total=0; total<(Lcd_Dev.width)*range; total++){
S				LCD_ADDR->lcd_data = color;
S			}
S		}
S	}
S	for(index=0; index<320/range; index++){
S		if(index%2 == 1){
S			lcdSetWindow(0, index*range, 480-1, index*range+range);
S			for(total=0; total<(Lcd_Dev.width)*range; total++){
S				LCD_ADDR->lcd_data = color;
S			}
S		}
S	}
S
N#else
N		for(index=0; index<480/range; index++){
N		if(index%2 == 0){
N			lcdSetWindow(0, index*range, 320-1, index*range+range);
N			for(total=0; total<(Lcd_Dev.width)*range; total++){
N				LCD_ADDR->lcd_data = color;
X				((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = color;
N			}
N		}
N	}
N	for(index=0; index<480/range; index++){
N		if(index%2 == 1){
N			lcdSetWindow(0, index*range,320-1, index*range+range);
N			for(total=0; total<(Lcd_Dev.width)*range; total++){
N				LCD_ADDR->lcd_data = color;
X				((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = color;
N			}
N		}
N	}
N
N#endif
N	
N	//lcdDisplayOn();
N#endif
N}
N//剧ず 寮
Nvoid lcdDisplayOn(void)
N{
N	lcdWriteReg(0x0029, 0);
N}
N//剧ず 
Nvoid lcdDisplayOff(void)
N{
N	lcdWriteReg(0x0028, 0);
N}
N//璁剧疆浣缃
Nvoid lcdSetCursor(u16 x, u16 y)
N{
N	lcdWriteCmd(Lcd_Dev.x_cmd);	
N	lcdWriteData(x>>8);
N	lcdWriteData(0x00FF&x);
N	lcdWriteData((x)>>8);
N	lcdWriteData((x));
N
N	lcdWriteCmd(Lcd_Dev.y_cmd);	
N	lcdWriteData(y>>8);
N	lcdWriteData(0x00FF&y);		
N	lcdWriteData((y)>>8);
N	lcdWriteData((y));
N	//寮濮瀵瀛
N	lcdWriteMem();
N}
N//璁惧涓涓╁舰剧ず
Nvoid lcdSetWindow(u16 x_start, u16 y_start, u16 x_end, u16 y_end)
N{
N	//璁剧疆杈圭
N	lcdWriteCmd(Lcd_Dev.x_cmd);	
N	lcdWriteData(x_start>>8);		//璧峰楂8浣
N	lcdWriteData(0x00FF&x_start);	//璧峰浣8浣
N	lcdWriteData(x_end>>8);			//缁楂8浣
N	lcdWriteData(0x00FF&x_end);		//缁浣8浣
N	//璁剧疆琛杈圭
N	lcdWriteCmd(Lcd_Dev.y_cmd);	
N	lcdWriteData(y_start>>8);
N	lcdWriteData(0x00FF&y_start);
N	lcdWriteData(y_end>>8);
N	lcdWriteData(0x00FF&y_end);
N	//寮濮瀵瀛 
N	lcdWriteMem();
N}
N
N//ㄥ骞涓缁朵涓绱
Nvoid lcdDrawPoint(u16 x, u16 y, LcdPen* pen)
N{
N	lcdSetCursor(x,y);
N	LCD_ADDR->lcd_cmd = 0x2c;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_cmd = 0x2c;
N	LCD_ADDR->lcd_data = pen->color;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = pen->color;
N}
N
Nvoid lcdDrawLine(u16 x1,u16 y1,u16 x2,u16 y2,LcdPen* pen)
N{
N	float temp,x,y,z;
N	u16 i,j,ax,ay;
N	ax = x2;
N	ay = y2;
N	/*
N	x = 1;
N	y = 0;
N	x = x1>x2?x1 - x2:x2 - x1;
N	y = y1>y2?y1 - y2:y2 - y1;
N	*/
N
N	x = x1 - x2;
N	y = y1 - y2;
N	if(x1 != x2)
N		temp = y/x;
N	
N	if(x1 > x2)
N	{
N		ax = x1;
N		x1 = x2;
N		ay = y1;
N		y1 = y2;
N	}
N	
N	if(x1 == ax)
N	{
N		for(i = y1;i <= ay;i++)
N			lcdDrawPoint(x1,i,pen);
N		return;
N	}
N	if(y1 == ay)
N	{
N		for(i = x1;i <= ax;i++)
N			lcdDrawPoint(i,y1,pen);
N		return;
N	}
N	else
N		for(i = x1;i <= ax;i++)
N		{
N			z = temp*(i-x1)+y1;
N			if(temp >= 1)
N				for(j = 0;j <= (u16)temp;j++)
N					lcdDrawPoint(i,z+j,pen);
N				lcdDrawPoint(i,z,pen);
N		}
N}
N
Nvoid lcdDrawRect(u16 x,u16 y,u16 width,u16 height,LcdPen* pen)
N{
N	u32 i;
N	u32 total = width*height;
N	if(P_SET_BRUSH == pen->brush)
N	{
N		/*for(i = 0;i <= height;i++)
N			lcdDrawLine(x, y+i, x+width, y+i,pen);
N		*/
N		lcdSetWindow(x,y,x+width,y+height);
N		for(i = 0;i < total;i++)
N			LCD_ADDR->lcd_data = pen->color;
X			((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = pen->color;
N		
N	}
N	else if(P_SET_NOBRUSH == pen->brush)
N	{
N		lcdDrawLine(x, y, x+width, y,pen);
N		lcdDrawLine(x, y, x, y+height,pen);
N		lcdDrawLine(x, y+height, x+width, y+height,pen);
N		lcdDrawLine(x+width,y,x+width,y+height,pen);
N	}
N}
N
N
N//缁朵涓瀛绗
Nu8 lcdDrawChr(u16 x, u16 y, u8 ch, LcdPen* p)
N{
N	u8	byte_x;//褰归靛ㄥ
N	u8	byte, bit;
N	u8	temp;
N	u16 y0 = y;//褰瀛浣绱楂搴
N	
N	ch -= ' ';//瀛搴涓浠 寮濮剧ず
N	
N	switch(p->p_size)
N	{
N		case P_S16EN:
N			byte_x = 16;
N			break;
N		case P_S32EN:
N			byte_x = 64;
N			break;
N		default:
N			return 1;
N	}
N	
N	//澶灞寰琛ㄧず锛版涓瀛绗
N	for(byte=0; byte<byte_x; byte++)
N	{
N		//峰瀛绗瀵瑰归靛
N		switch(p->p_size)
N		{
N			case P_S16EN:
N				temp = asc2_1608[ch][byte];
N				break;
N			case P_S32EN:
N				temp = asc2_3210[ch][byte];
N				break;
N			default:
N				return 1;
N		}
N		
N		//浣剧ずㄦ恫朵
N		for(bit=0; bit<8; bit++)
N		{
N			if(temp&0x80)
N			{
N				lcdDrawPoint(x, y, p);
N			}
N			temp <<= 1;//颁涓浣
N			y++;//存瑰涓绉讳涓绱
N			if(y>Lcd_Dev.height)
N			{
N				return 1;
N			}
N		}
N
N		if((y-y0)==p->p_size)
N		{
N			y = y0;
N			x++;
N			//ゆ瓒烘按骞宠竟
N			if(x>Lcd_Dev.width)
N			{
N				return 1;
N			}
N		}
N	}
N	return 0;
N}
N
N//ㄦ瀹浣缃缁朵涓瀛绗涓诧杩0杩0
Nu8 lcdDrawStr(u16 x, u16 y, u8* str, LcdPen* p)
N{
N	u8 inc = 0;
N	
N	switch(p->p_size)
N	{
N		case P_S16EN:
N			inc = 16;
N			break;
N		case P_S32EN:
N			inc = 32;
N			break;
N		default:
N			return 1;
N	}
N	
N	while(*str)
N	{
N		if(P_DIR_HOR==p->direct)
N		{
N			if(*str>=0x81)
N			{
N				x += inc;
N				str += 2;
N			}
N			else
N			{
N				if(lcdDrawChr(x, y, *str, p))
N				{
N					return 1;
N				}
N				x += inc/2;	
N				str += 1;
N			}
N		}
N		else if(P_DIR_VER==p->direct)
N		{
N			if(*str>=0x81)
N			{
N				str += 2;
N			}
N			else
N			{
N				if(lcdDrawChr(x, y, *str, p))
N				{
N					return 1;
N				}	
N				str += 1;
N			}
N			y += inc;
N		}
N	}
N	return 0;
N}
N
N
N//缁朵涓卞涓绱缁
Nvoid lcdDrawBigPoint(u16 x, u16 y, LcdPen* p)
N{
N	lcdDrawPoint(x, y,  p);
N	lcdDrawPoint(x+1, y, p);
N	lcdDrawPoint(x, y+1, p);
N	lcdDrawPoint(x+1, y+1, p);
N}
N
Nu16 LCD_DecToRGB(u8 R, u8 G, u8 B)
N{
N	u16 color;
N	color = R;
N	color <<= 5;
N	color = color + G;
N	color <<= 6;
N	color = color +B;
N	return color;
N}
N
N
N//!-2
N/* **************************************************
N * 芥板
N * *************************************************/
N//LCD16浣浠
Nstatic void lcdWriteCmd(u16 cmd)
N{
N	LCD_ADDR->lcd_cmd = cmd;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_cmd = cmd;
N}
N//LCD16浣版
Nstatic void lcdWriteData(u16 data)
N{
N	LCD_ADDR->lcd_data = data;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = data;
N}
N//璇诲LCD版
Nstatic u16 lcdReadData(void)
N{
N	return LCD_ADDR->lcd_data;
X	return ((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data;
N}
N//瀹瀵瀛
Nstatic void lcdWriteReg(u8 lcd_reg, u16 reg_val)
N{
N	LCD_ADDR->lcd_cmd = lcd_reg;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_cmd = lcd_reg;
N	LCD_ADDR->lcd_data = reg_val;
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_data = reg_val;
N}
N//璇诲瀹瀵瀛
Nstatic u16 lcdReadReg(u8 lcd_reg)
N{
N	lcdWriteCmd(lcd_reg);
N	_delay_us(5);
N	return lcdReadData();
N}
N/* *********************************************************** 
N * Memory Write
N * This command transfers image data from the host processor
N * to ILI9486Ls frame memory starting at the pixel location 
N * specified by preceding Column Address Set (2Ah) and Page 
N * Address Set (2Bh) commands.
N * ***********************************************************/
Nstatic void lcdWriteMem(void)
N{
N	LCD_ADDR->lcd_cmd = Lcd_Dev.wr_cmd; //2Ch
X	((LcdAddr*)((u32)(0x6C000000|0x000007FE)))->lcd_cmd = Lcd_Dev.wr_cmd; 
N}
N//璁剧疆璁惧
Nstatic void lcdSetParam(void)
N{
N	//Column Address set
N	Lcd_Dev.x_cmd = 0x2A;
N	//Page Address Set
N	Lcd_Dev.y_cmd = 0x2B;
N	/* *********************************************************** 
N	 * Memory Write
N	 * This command transfers image data from the host processor
N	 * to ILI9486Ls frame memory starting at the pixel location 
N	 * specified by preceding Column Address Set (2Ah) and Page 
N	 * Address Set (2Bh) commands.
N	 * ***********************************************************/
N	Lcd_Dev.wr_cmd = 0x2C;
N
N#if LCD_VIEW_MODE == LCD_HOR_MODE
X#if 0 == 1
S	Lcd_Dev.d_mode = LCD_HOR_MODE;
S	Lcd_Dev.width = 480;
S	Lcd_Dev.height = 320;
S	lcdWriteReg(0x36, 0x30);
N#else
N	Lcd_Dev.d_mode = LCD_VER_MODE;
X	Lcd_Dev.d_mode = 0;
N	Lcd_Dev.width = 320;
N	Lcd_Dev.height = 480;
N	lcdWriteReg(0x36, 0x52);
N#endif
N}
N
N
N
N
N
N
N
N
N
