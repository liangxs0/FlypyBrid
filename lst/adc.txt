; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\adc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\core -I.\devices -I.\app -I.\boot -I.\app\RES\Num -I.\app\RES\Pic -I"D:\Program Files\Keil\ARM\RV31\INC" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\obj\adc.crf devices\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Adc_Init PROC
;;;6      //我们默认将开启通道0~3																	   
;;;7      void  Adc_Init(void)
000000  4850              LDR      r0,|L1.324|
;;;8      {
;;;9      	RCC->APB2ENR |= 1<<2 | 1<<9;	  //使能ADC1通道时钟
000002  6980              LDR      r0,[r0,#0x18]
000004  f4407001          ORR      r0,r0,#0x204
000008  494e              LDR      r1,|L1.324|
00000a  6188              STR      r0,[r1,#0x18]
;;;10      
;;;11     	RCC->CFGR |= 0x2<<14;    //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  f4404000          ORR      r0,r0,#0x8000
000014  6048              STR      r0,[r1,#4]
;;;12     
;;;13     	//PA1 作为模拟通道输入引脚                         
;;;14     	GPIOA->CRL &= ~(0x3<<6);
000016  484c              LDR      r0,|L1.328|
000018  6800              LDR      r0,[r0,#0]
00001a  f02000c0          BIC      r0,r0,#0xc0
00001e  494a              LDR      r1,|L1.328|
000020  6008              STR      r0,[r1,#0]
;;;15     	RCC->APB2RSTR |= 1<<9;//复位ADC1,将外设 ADC1 的全部寄存器重设为缺省值
000022  4848              LDR      r0,|L1.324|
000024  68c0              LDR      r0,[r0,#0xc]
000026  f4407000          ORR      r0,r0,#0x200
00002a  4946              LDR      r1,|L1.324|
00002c  60c8              STR      r0,[r1,#0xc]
;;;16     
;;;17     	ADC1->CR1 &= ~(0xf<<16);			//ADC工作模式:ADC1和ADC2工作在独立模式
00002e  4847              LDR      r0,|L1.332|
000030  6800              LDR      r0,[r0,#0]
000032  f4202070          BIC      r0,r0,#0xf0000
000036  4945              LDR      r1,|L1.332|
000038  6008              STR      r0,[r1,#0]
;;;18     	ADC1->CR1 &= ~(1<<8);		//模数转换工作在单通道模式
00003a  4608              MOV      r0,r1
00003c  6800              LDR      r0,[r0,#0]
00003e  f4207080          BIC      r0,r0,#0x100
000042  6008              STR      r0,[r1,#0]
;;;19     	ADC1->CR2 &= ~(1<<1);		//模数转换工作在单次转换模式
000044  1d08              ADDS     r0,r1,#4
000046  6800              LDR      r0,[r0,#0]
000048  f0200002          BIC      r0,r0,#2
00004c  1d09              ADDS     r1,r1,#4
00004e  6008              STR      r0,[r1,#0]
;;;20     	ADC1->CR2 |= 0x7<<17;		//转换由软件而不是外部触发启动
000050  4608              MOV      r0,r1
000052  6800              LDR      r0,[r0,#0]
000054  f4402060          ORR      r0,r0,#0xe0000
000058  6008              STR      r0,[r1,#0]
;;;21     	ADC1->CR2 &= ~(1<<11);	//ADC数据右对齐
00005a  4608              MOV      r0,r1
00005c  6800              LDR      r0,[r0,#0]
00005e  f4206000          BIC      r0,r0,#0x800
000062  6008              STR      r0,[r1,#0]
;;;22     	ADC1->SQR1 &= ~(0xf<<20);	//顺序进行规则转换的ADC通道的数目
000064  4839              LDR      r0,|L1.332|
000066  3028              ADDS     r0,r0,#0x28
000068  6800              LDR      r0,[r0,#0]
00006a  f4200070          BIC      r0,r0,#0xf00000
00006e  4937              LDR      r1,|L1.332|
000070  3128              ADDS     r1,r1,#0x28
000072  6008              STR      r0,[r1,#0]
;;;23     
;;;24       ADC1->CR2 |= 1<<0;		//使能指定的ADC1
000074  4835              LDR      r0,|L1.332|
000076  1d00              ADDS     r0,r0,#4
000078  6800              LDR      r0,[r0,#0]
00007a  f0400001          ORR      r0,r0,#1
00007e  4933              LDR      r1,|L1.332|
000080  1d09              ADDS     r1,r1,#4
000082  6008              STR      r0,[r1,#0]
;;;25     	ADC1->CR2 |= 1<<3;		//使能复位校准  
000084  4608              MOV      r0,r1
000086  6800              LDR      r0,[r0,#0]
000088  f0400008          ORR      r0,r0,#8
00008c  6008              STR      r0,[r1,#0]
;;;26     	
;;;27     	while((ADC1->CR2 & 1<<3) != 0);	//等待复位校准结束
00008e  bf00              NOP      
                  |L1.144|
000090  482e              LDR      r0,|L1.332|
000092  1d00              ADDS     r0,r0,#4
000094  6800              LDR      r0,[r0,#0]
000096  f0100f08          TST      r0,#8
00009a  d1f9              BNE      |L1.144|
;;;28     	
;;;29     	ADC1->CR2 |= 1<<2;	 //开启AD校准
00009c  482b              LDR      r0,|L1.332|
00009e  1d00              ADDS     r0,r0,#4
0000a0  6800              LDR      r0,[r0,#0]
0000a2  f0400004          ORR      r0,r0,#4
0000a6  4929              LDR      r1,|L1.332|
0000a8  1d09              ADDS     r1,r1,#4
0000aa  6008              STR      r0,[r1,#0]
;;;30      
;;;31     	while((ADC1->CR2 & 1<<2) != 0);	 //等待校准结束
0000ac  bf00              NOP      
                  |L1.174|
0000ae  4827              LDR      r0,|L1.332|
0000b0  1d00              ADDS     r0,r0,#4
0000b2  6800              LDR      r0,[r0,#0]
0000b4  f0100f04          TST      r0,#4
0000b8  d1f9              BNE      |L1.174|
;;;32      
;;;33     //	ADC_SoftwareStartConvCmd(ADC1, ENABLE);		//使能指定的ADC1的软件转换启动功能
;;;34     
;;;35     }				  
0000ba  4770              BX       lr
;;;36     //获得ADC值
                          ENDP

                  Get_Adc PROC
;;;37     //ch:通道值 0~3
;;;38     u16 Get_Adc(u8 ch)   
0000bc  4601              MOV      r1,r0
;;;39     {
;;;40       //设置指定ADC的规则组通道，一个序列，采样时间
;;;41     	ADC1->SMPR2 |= 0xF<<(3*ch);
0000be  4823              LDR      r0,|L1.332|
0000c0  300c              ADDS     r0,r0,#0xc
0000c2  6800              LDR      r0,[r0,#0]
0000c4  eb010341          ADD      r3,r1,r1,LSL #1
0000c8  220f              MOVS     r2,#0xf
0000ca  409a              LSLS     r2,r2,r3
0000cc  4310              ORRS     r0,r0,r2
0000ce  4a1f              LDR      r2,|L1.332|
0000d0  320c              ADDS     r2,r2,#0xc
0000d2  6010              STR      r0,[r2,#0]
;;;42     	ADC1->SQR3 &= ~(0x1F<<0);
0000d4  481d              LDR      r0,|L1.332|
0000d6  3030              ADDS     r0,r0,#0x30
0000d8  6800              LDR      r0,[r0,#0]
0000da  f020001f          BIC      r0,r0,#0x1f
0000de  4a1b              LDR      r2,|L1.332|
0000e0  3230              ADDS     r2,r2,#0x30
0000e2  6010              STR      r0,[r2,#0]
;;;43     	ADC1->SQR3 |= ch << 0;		//ADC1,ADC通道,采样时间为239.5周期	  			    
0000e4  4610              MOV      r0,r2
0000e6  6800              LDR      r0,[r0,#0]
0000e8  4308              ORRS     r0,r0,r1
0000ea  6010              STR      r0,[r2,#0]
;;;44       
;;;45     	ADC1->CR2 |= 0x00500000;	//使能指定的ADC1的软件转换启动功能	
0000ec  4817              LDR      r0,|L1.332|
0000ee  1d00              ADDS     r0,r0,#4
0000f0  6800              LDR      r0,[r0,#0]
0000f2  f44000a0          ORR      r0,r0,#0x500000
0000f6  4a15              LDR      r2,|L1.332|
0000f8  1d12              ADDS     r2,r2,#4
0000fa  6010              STR      r0,[r2,#0]
;;;46     	 
;;;47     	while(!(ADC1->SR & 1<<1));//等待转换结束
0000fc  bf00              NOP      
                  |L1.254|
0000fe  4813              LDR      r0,|L1.332|
000100  1f00              SUBS     r0,r0,#4
000102  6800              LDR      r0,[r0,#0]
000104  f0100f02          TST      r0,#2
000108  d0f9              BEQ      |L1.254|
;;;48     
;;;49     	return ADC1->DR;	//返回最近一次ADC1规则组的转换结果
00010a  4810              LDR      r0,|L1.332|
00010c  3048              ADDS     r0,r0,#0x48
00010e  6800              LDR      r0,[r0,#0]
000110  b280              UXTH     r0,r0
;;;50     }
000112  4770              BX       lr
;;;51     
                          ENDP

                  Get_Adc_Average PROC
;;;52     u16 Get_Adc_Average(u8 ch,u8 times)
000114  e92d41f0          PUSH     {r4-r8,lr}
;;;53     {
000118  4607              MOV      r7,r0
00011a  460c              MOV      r4,r1
;;;54     	u32 temp_val=0;
00011c  2500              MOVS     r5,#0
;;;55     	u8 t;
;;;56     	for(t=0;t<times;t++)
00011e  2600              MOVS     r6,#0
000120  e008              B        |L1.308|
                  |L1.290|
;;;57     	{
;;;58     		temp_val+=Get_Adc(ch);
000122  4638              MOV      r0,r7
000124  f7fffffe          BL       Get_Adc
000128  4405              ADD      r5,r5,r0
;;;59     		_delay_ms(5);
00012a  2005              MOVS     r0,#5
00012c  f7fffffe          BL       _delay_ms
000130  1c70              ADDS     r0,r6,#1              ;56
000132  b2c6              UXTB     r6,r0                 ;56
                  |L1.308|
000134  42a6              CMP      r6,r4                 ;56
000136  dbf4              BLT      |L1.290|
;;;60     	}
;;;61     	return temp_val/times;
000138  fbb5f0f4          UDIV     r0,r5,r4
00013c  b280              UXTH     r0,r0
;;;62     } 	 
00013e  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP

000142  0000              DCW      0x0000
                  |L1.324|
                          DCD      0x40021000
                  |L1.328|
                          DCD      0x40010800
                  |L1.332|
                          DCD      0x40012404
