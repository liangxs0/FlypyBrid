; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\fsmc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\fsmc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\core -I.\devices -I.\app -I.\boot -I.\app\RES\Num -I.\app\RES\Pic -I"D:\Program Files\Keil\ARM\RV31\INC" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\obj\fsmc.crf devices\fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_SRAM_init PROC
;;;6      //FSMC初始化外部SRAM
;;;7      void FSMC_SRAM_init(void)
000000  4859              LDR      r0,|L1.360|
;;;8      {
;;;9      	RCC->AHBENR |= 1<<8;		//FSMC时钟使能
000002  6940              LDR      r0,[r0,#0x14]
000004  f4407080          ORR      r0,r0,#0x100
000008  4957              LDR      r1,|L1.360|
00000a  6148              STR      r0,[r1,#0x14]
;;;10     	/*
;;;11      地址线：GPIOF（0~5 . 12~15）、GPIOG（0~5）、GPIOD（11.12.13） | 总共19跟地址线
;;;12     	* 数据线：GPIOE（7~15）、GPIOD（0.1.8.9.10.14.15）		| 总共16跟数据线
;;;13     	* 配置线：GPIOE（0.1）、GPIOD（4.5）、GPIOG（10）
;;;14     	* 需要配置的IO口：
;;;15     	* GPIOD（0/1/4/5/8-15）	12
;;;16     	* GPIOE（0/1/7-15）			11
;;;17     	* GPIOF（0-5/12-15）		10
;;;18     	* GPIOG（0-5/10）				7
;;;19     	*/
;;;20     	RCC->APB2ENR |= 1<<5 | 1<<6 | 1<<7 | 1<<8;
00000c  4608              MOV      r0,r1
00000e  6980              LDR      r0,[r0,#0x18]
000010  f44070f0          ORR      r0,r0,#0x1e0
000014  6188              STR      r0,[r1,#0x18]
;;;21     	
;;;22     	//将各个IO口置为复用推挽输出，配置前将寄存器清零
;;;23     	GPIOD->CRH &= 0x00000000;
000016  4855              LDR      r0,|L1.364|
000018  6800              LDR      r0,[r0,#0]
00001a  2000              MOVS     r0,#0
00001c  4953              LDR      r1,|L1.364|
00001e  6008              STR      r0,[r1,#0]
;;;24     	GPIOD->CRH |= 0xBBBBBBBB;
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  f04030bb          ORR      r0,r0,#0xbbbbbbbb
000028  6008              STR      r0,[r1,#0]
;;;25     	GPIOD->CRL &= 0xFF00FF00;
00002a  1f08              SUBS     r0,r1,#4
00002c  6800              LDR      r0,[r0,#0]
00002e  f00020ff          AND      r0,r0,#0xff00ff00
000032  1f09              SUBS     r1,r1,#4
000034  6008              STR      r0,[r1,#0]
;;;26     	GPIOD->CRL |= 0x00BB00BB;
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  f04010bb          ORR      r0,r0,#0xbb00bb
00003e  6008              STR      r0,[r1,#0]
;;;27     	
;;;28     	GPIOE->CRH &= 0x00000000;
000040  484b              LDR      r0,|L1.368|
000042  6800              LDR      r0,[r0,#0]
000044  2000              MOVS     r0,#0
000046  494a              LDR      r1,|L1.368|
000048  6008              STR      r0,[r1,#0]
;;;29     	GPIOE->CRH |= 0xBBBBBBBB;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]
00004e  f04030bb          ORR      r0,r0,#0xbbbbbbbb
000052  6008              STR      r0,[r1,#0]
;;;30     	GPIOE->CRL &= 0x0FFFFF00;
000054  1f08              SUBS     r0,r1,#4
000056  6800              LDR      r0,[r0,#0]
000058  4946              LDR      r1,|L1.372|
00005a  4008              ANDS     r0,r0,r1
00005c  4944              LDR      r1,|L1.368|
00005e  1f09              SUBS     r1,r1,#4
000060  6008              STR      r0,[r1,#0]
;;;31     	GPIOE->CRL |= 0xB00000BB;
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  4944              LDR      r1,|L1.376|
000068  4308              ORRS     r0,r0,r1
00006a  4941              LDR      r1,|L1.368|
00006c  1f09              SUBS     r1,r1,#4
00006e  6008              STR      r0,[r1,#0]
;;;32     	
;;;33     	GPIOF->CRH &= 0x0000FFFF;
000070  4842              LDR      r0,|L1.380|
000072  6800              LDR      r0,[r0,#0]
000074  b280              UXTH     r0,r0
000076  4941              LDR      r1,|L1.380|
000078  6008              STR      r0,[r1,#0]
;;;34     	GPIOF->CRH |= 0xBBBB0000;
00007a  4608              MOV      r0,r1
00007c  6800              LDR      r0,[r0,#0]
00007e  4940              LDR      r1,|L1.384|
000080  4308              ORRS     r0,r0,r1
000082  493e              LDR      r1,|L1.380|
000084  6008              STR      r0,[r1,#0]
;;;35     	GPIOF->CRL &= 0xFF000000;
000086  1f08              SUBS     r0,r1,#4
000088  6800              LDR      r0,[r0,#0]
00008a  f000407f          AND      r0,r0,#0xff000000
00008e  1f09              SUBS     r1,r1,#4
000090  6008              STR      r0,[r1,#0]
;;;36     	GPIOF->CRL |= 0x00BBBBBB;
000092  4608              MOV      r0,r1
000094  6800              LDR      r0,[r0,#0]
000096  493b              LDR      r1,|L1.388|
000098  4308              ORRS     r0,r0,r1
00009a  4938              LDR      r1,|L1.380|
00009c  1f09              SUBS     r1,r1,#4
00009e  6008              STR      r0,[r1,#0]
;;;37     	
;;;38     	GPIOG->CRH &= 0xFFFFF0FF;
0000a0  4839              LDR      r0,|L1.392|
0000a2  6840              LDR      r0,[r0,#4]
0000a4  f4206070          BIC      r0,r0,#0xf00
0000a8  4937              LDR      r1,|L1.392|
0000aa  6048              STR      r0,[r1,#4]
;;;39     	GPIOG->CRH |= 0x00000B00;
0000ac  4608              MOV      r0,r1
0000ae  6840              LDR      r0,[r0,#4]
0000b0  f4406030          ORR      r0,r0,#0xb00
0000b4  6048              STR      r0,[r1,#4]
;;;40     	GPIOG->CRL &= 0xFF000000;
0000b6  4608              MOV      r0,r1
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f000407f          AND      r0,r0,#0xff000000
0000be  6008              STR      r0,[r1,#0]
;;;41     	GPIOG->CRL |= 0x00BBBBBB;
0000c0  4608              MOV      r0,r1
0000c2  6800              LDR      r0,[r0,#0]
0000c4  492f              LDR      r1,|L1.388|
0000c6  4308              ORRS     r0,r0,r1
0000c8  492f              LDR      r1,|L1.392|
0000ca  6008              STR      r0,[r1,#0]
;;;42     	
;;;43     	//寄存器清零
;;;44     	//Bank1共有NE1~4，每个端口都有一个BCR+TCR，所以共有8个寄存器
;;;45     	//使用的是NE3，即对应BTCR[4]、BTCR[5]
;;;46     	FSMC_Bank1->BTCR[4] = 0x00000000;
0000cc  2000              MOVS     r0,#0
0000ce  f04f4120          MOV      r1,#0xa0000000
0000d2  6108              STR      r0,[r1,#0x10]
;;;47     	FSMC_Bank1->BTCR[5] = 0x00000000;
0000d4  6148              STR      r0,[r1,#0x14]
;;;48     	FSMC_Bank1E->BWTR[4] = 0x00000000;
0000d6  492d              LDR      r1,|L1.396|
0000d8  6008              STR      r0,[r1,#0]
;;;49     	
;;;50     	
;;;51     	//操作BCR寄存器	使用异步模式，模式A（读写共用一个时序寄存器）
;;;52     	//BTCR[偶数]：BCR寄存器；BTCR[奇数]：BTR寄存器
;;;53     	FSMC_Bank1->BTCR[4] |= 1<< 14;
0000da  f04f4020          MOV      r0,#0xa0000000
0000de  6900              LDR      r0,[r0,#0x10]
0000e0  f4404080          ORR      r0,r0,#0x4000
0000e4  f04f4120          MOV      r1,#0xa0000000
0000e8  6108              STR      r0,[r1,#0x10]
;;;54     	FSMC_Bank1->BTCR[4] |= 1<< 12;			//存储器写使能
0000ea  4608              MOV      r0,r1
0000ec  6900              LDR      r0,[r0,#0x10]
0000ee  f4405080          ORR      r0,r0,#0x1000
0000f2  6108              STR      r0,[r1,#0x10]
;;;55     	FSMC_Bank1->BTCR[4] |= 1<< 4;				//存储器数据宽度为16bit
0000f4  4608              MOV      r0,r1
0000f6  6900              LDR      r0,[r0,#0x10]
0000f8  f0400010          ORR      r0,r0,#0x10
0000fc  6108              STR      r0,[r1,#0x10]
;;;56     	FSMC_Bank1->BTCR[4] |= 0<< 2;
0000fe  4608              MOV      r0,r1
000100  6900              LDR      r0,[r0,#0x10]
000102  6108              STR      r0,[r1,#0x10]
;;;57     	
;;;58     	/*
;;;59     	FSMC_Bank1->BTCR[4] |= 1<<12;	//存储器 写 使能
;;;60     	FSMC_Bank1->BTCR[4] |= 1<<14;	//读 写 使用不同时序
;;;61     	FSMC_Bank1->BTCR[4] |= 1<<4;	//存储数据宽度为16位
;;;62     	//写 控制
;;;63     	FSMC_Bank1E->BWTR[4] |= 0<<28;	//MODE A
;;;64     	FSMC_Bank1E->BWTR[4] |= 0<<0;	//地址建立时间为1*HCLK
;;;65     	*/
;;;66     	//操作BTR寄存器
;;;67     	FSMC_Bank1->BTCR[5] |= 0<<28;
000104  4608              MOV      r0,r1
000106  6940              LDR      r0,[r0,#0x14]
000108  6148              STR      r0,[r1,#0x14]
;;;68     	FSMC_Bank1->BTCR[5] |= 0x2<<8;			//数据保存时间(DATAST) 为4个HCLK 4/72M = 55ns
00010a  4608              MOV      r0,r1
00010c  6940              LDR      r0,[r0,#0x14]
00010e  f4407000          ORR      r0,r0,#0x200
000112  6148              STR      r0,[r1,#0x14]
;;;69     	FSMC_Bank1->BTCR[5] |= 1<<0;				//地址建立时间ADDSET为1个HCLK
000114  4608              MOV      r0,r1
000116  6940              LDR      r0,[r0,#0x14]
000118  f0400001          ORR      r0,r0,#1
00011c  6148              STR      r0,[r1,#0x14]
;;;70     	//闪存写时序寄存器
;;;71     	FSMC_Bank1E->BWTR[4] |= 3<<8;
00011e  4608              MOV      r0,r1
000120  f8d00114          LDR      r0,[r0,#0x114]
000124  f4407040          ORR      r0,r0,#0x300
000128  f8c10114          STR      r0,[r1,#0x114]
;;;72     	//使能BANK1区域3
;;;73     	FSMC_Bank1->BTCR[4] |= 1<<0;
00012c  4608              MOV      r0,r1
00012e  6900              LDR      r0,[r0,#0x10]
000130  f0400001          ORR      r0,r0,#1
000134  6108              STR      r0,[r1,#0x10]
;;;74     }
000136  4770              BX       lr
;;;75     
                          ENDP

                  FSMC_SRAM_WriteBuffer PROC
;;;76     void FSMC_SRAM_WriteBuffer(u8* pBuffer,u32 WriteAddr,u32 n)
000138  b510              PUSH     {r4,lr}
;;;77     {
;;;78     	while(n != 0)
00013a  e006              B        |L1.330|
                  |L1.316|
;;;79     	{
;;;80     		*(vu8*)(FSMC_BASE+WriteAddr) = *pBuffer;
00013c  7804              LDRB     r4,[r0,#0]
00013e  f04f43d0          MOV      r3,#0x68000000
000142  545c              STRB     r4,[r3,r1]
;;;81     		pBuffer++;
000144  1c40              ADDS     r0,r0,#1
;;;82     		WriteAddr+=2;
000146  1c89              ADDS     r1,r1,#2
;;;83     		n--;
000148  1e52              SUBS     r2,r2,#1
                  |L1.330|
00014a  2a00              CMP      r2,#0                 ;78
00014c  d1f6              BNE      |L1.316|
;;;84     	}
;;;85     }
00014e  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  FSMC_SRAM_ReadBuffer PROC
;;;87     void FSMC_SRAM_ReadBuffer(u8* pBuffer,u32 ReadAddr,u32 n)
000150  e006              B        |L1.352|
                  |L1.338|
;;;88     {
;;;89     	while(n != 0)
;;;90     	{
;;;91     		*pBuffer = *(vu8*)(FSMC_BASE+ReadAddr);
000152  f04f43d0          MOV      r3,#0x68000000
000156  5c5b              LDRB     r3,[r3,r1]
000158  7003              STRB     r3,[r0,#0]
;;;92     		pBuffer++;
00015a  1c40              ADDS     r0,r0,#1
;;;93     		ReadAddr+=2;
00015c  1c89              ADDS     r1,r1,#2
;;;94     		n--;
00015e  1e52              SUBS     r2,r2,#1
                  |L1.352|
000160  2a00              CMP      r2,#0                 ;89
000162  d1f6              BNE      |L1.338|
;;;95     	}
;;;96     }
000164  4770              BX       lr
;;;97     
                          ENDP

000166  0000              DCW      0x0000
                  |L1.360|
                          DCD      0x40021000
                  |L1.364|
                          DCD      0x40011404
                  |L1.368|
                          DCD      0x40011804
                  |L1.372|
                          DCD      0x0fffff00
                  |L1.376|
                          DCD      0xb00000bb
                  |L1.380|
                          DCD      0x40011c04
                  |L1.384|
                          DCD      0xbbbb0000
                  |L1.388|
                          DCD      0x00bbbbbb
                  |L1.392|
                          DCD      0x40012000
                  |L1.396|
                          DCD      0xa0000114
