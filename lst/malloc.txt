; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\malloc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\malloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\core -I.\devices -I.\app -I.\boot -I.\app\RES\Num -I.\app\RES\Pic -I"D:\Program Files\Keil\ARM\RV31\INC" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\obj\malloc.crf core\malloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  mymemcpy PROC
;;;28     //n:需要复制的内存长度(字节为单位)
;;;29     void mymemcpy(void *des,void *src,u32 n)  
000000  b570              PUSH     {r4-r6,lr}
;;;30     {  
;;;31         u8 *xdes=des;
000002  4603              MOV      r3,r0
;;;32     	u8 *xsrc=src; 
000004  460c              MOV      r4,r1
;;;33         while(n--)*xdes++=*xsrc++;  
000006  e003              B        |L1.16|
                  |L1.8|
000008  f8145b01          LDRB     r5,[r4],#1
00000c  f8035b01          STRB     r5,[r3],#1
                  |L1.16|
000010  0015              MOVS     r5,r2
000012  f1a20201          SUB      r2,r2,#1
000016  d1f7              BNE      |L1.8|
;;;34     }  
000018  bd70              POP      {r4-r6,pc}
;;;35     //设置内存
                          ENDP

                  mymemset PROC
;;;38     //count:需要设置的内存大小(字节为单位)
;;;39     void mymemset(void *s,u8 c,u32 count)  
00001a  b530              PUSH     {r4,r5,lr}
;;;40     {  
;;;41         u8 *xs = s;  
00001c  4603              MOV      r3,r0
;;;42         while(count--)*xs++=c;  
00001e  e001              B        |L1.36|
                  |L1.32|
000020  f8031b01          STRB     r1,[r3],#1
                  |L1.36|
000024  0014              MOVS     r4,r2
000026  f1a20201          SUB      r2,r2,#1
00002a  d1f9              BNE      |L1.32|
;;;43     }	   
00002c  bd30              POP      {r4,r5,pc}
;;;44     //内存管理初始化  
                          ENDP

                  mem_init PROC
;;;45     //memx:所属内存块
;;;46     void mem_init(u8 memx)  
00002e  b510              PUSH     {r4,lr}
;;;47     {  
000030  4604              MOV      r4,r0
;;;48         mymemset(mallco_dev.memmap[memx], 0,memtblsize[memx]*2);//内存状态表数据清零  
000032  497b              LDR      r1,|L1.544|
000034  f8511024          LDR      r1,[r1,r4,LSL #2]
000038  004a              LSLS     r2,r1,#1
00003a  497a              LDR      r1,|L1.548|
00003c  f8510024          LDR      r0,[r1,r4,LSL #2]
000040  2100              MOVS     r1,#0
000042  f7fffffe          BL       mymemset
;;;49     	mymemset(mallco_dev.membase[memx], 0,memsize[memx]);	//内存池所有数据清零  
000046  4978              LDR      r1,|L1.552|
000048  f8512024          LDR      r2,[r1,r4,LSL #2]
00004c  4975              LDR      r1,|L1.548|
00004e  3908              SUBS     r1,r1,#8
000050  f8510024          LDR      r0,[r1,r4,LSL #2]
000054  2100              MOVS     r1,#0
000056  f7fffffe          BL       mymemset
;;;50     	mallco_dev.memrdy[memx]=1;								//内存管理初始化OK  
00005a  2101              MOVS     r1,#1
00005c  4871              LDR      r0,|L1.548|
00005e  3008              ADDS     r0,r0,#8
000060  5501              STRB     r1,[r0,r4]
;;;51     }  
000062  bd10              POP      {r4,pc}
;;;52     //获取内存使用率
                          ENDP

                  mem_perused PROC
;;;54     //返回值:使用率(0~100)
;;;55     u8 mem_perused(u8 memx)  
000064  b510              PUSH     {r4,lr}
;;;56     {  
000066  4601              MOV      r1,r0
;;;57         u32 used=0;  
000068  2300              MOVS     r3,#0
;;;58         u32 i;  
;;;59         for(i=0;i<memtblsize[memx];i++)  
00006a  2200              MOVS     r2,#0
00006c  e007              B        |L1.126|
                  |L1.110|
;;;60         {  
;;;61             if(mallco_dev.memmap[memx][i])used++; 
00006e  486d              LDR      r0,|L1.548|
000070  f8500021          LDR      r0,[r0,r1,LSL #2]
000074  f8300012          LDRH     r0,[r0,r2,LSL #1]
000078  b100              CBZ      r0,|L1.124|
00007a  1c5b              ADDS     r3,r3,#1
                  |L1.124|
00007c  1c52              ADDS     r2,r2,#1              ;59
                  |L1.126|
00007e  4868              LDR      r0,|L1.544|
000080  f8500021          LDR      r0,[r0,r1,LSL #2]     ;59
000084  4290              CMP      r0,r2                 ;59
000086  d8f2              BHI      |L1.110|
;;;62         } 
;;;63         return (used*100)/(memtblsize[memx]);  
000088  2064              MOVS     r0,#0x64
00008a  4358              MULS     r0,r3,r0
00008c  4c64              LDR      r4,|L1.544|
00008e  f8544021          LDR      r4,[r4,r1,LSL #2]
000092  fbb0f0f4          UDIV     r0,r0,r4
000096  b2c0              UXTB     r0,r0
;;;64     }  
000098  bd10              POP      {r4,pc}
;;;65     //内存分配(内部调用)
                          ENDP

                  mem_malloc PROC
;;;68     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;69     u32 mem_malloc(u8 memx,u32 size)  
00009a  e92d47f0          PUSH     {r4-r10,lr}
;;;70     {  
00009e  4604              MOV      r4,r0
0000a0  460f              MOV      r7,r1
;;;71         signed long offset=0;  
0000a2  2500              MOVS     r5,#0
;;;72         u16 nmemb;	//需要的内存块数  
;;;73     	u16 cmemb=0;//连续空内存块数
0000a4  46a9              MOV      r9,r5
;;;74         u32 i;  
;;;75         if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 
0000a6  485f              LDR      r0,|L1.548|
0000a8  3008              ADDS     r0,r0,#8
0000aa  5d00              LDRB     r0,[r0,r4]
0000ac  b920              CBNZ     r0,|L1.184|
0000ae  485d              LDR      r0,|L1.548|
0000b0  3810              SUBS     r0,r0,#0x10
0000b2  6801              LDR      r1,[r0,#0]  ; mallco_dev
0000b4  4620              MOV      r0,r4
0000b6  4788              BLX      r1
                  |L1.184|
;;;76         if(size==0)return 0XFFFFFFFF;//不需要分配
0000b8  b91f              CBNZ     r7,|L1.194|
0000ba  f04f30ff          MOV      r0,#0xffffffff
                  |L1.190|
;;;77         nmemb=size/memblksize[memx];  	//获取需要分配的连续内存块数
;;;78         if(size%memblksize[memx])nmemb++;  
;;;79         for(offset=memtblsize[memx]-1;offset>=0;offset--)//搜索整个内存控制区  
;;;80         {     
;;;81     		if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加
;;;82     		else cmemb=0;								//连续内存块清零
;;;83     		if(cmemb==nmemb)							//找到了连续nmemb个空内存块
;;;84     		{
;;;85                 for(i=0;i<nmemb;i++)  					//标注内存块非空 
;;;86                 {  
;;;87                     mallco_dev.memmap[memx][offset+i]=nmemb;  
;;;88                 }  
;;;89                 return (offset*memblksize[memx]);//返回偏移地址  
;;;90     		}
;;;91         }  
;;;92         return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;93     }  
0000be  e8bd87f0          POP      {r4-r10,pc}
                  |L1.194|
0000c2  485a              LDR      r0,|L1.556|
0000c4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;77
0000c8  fbb7f0f0          UDIV     r0,r7,r0              ;77
0000cc  b286              UXTH     r6,r0                 ;77
0000ce  4857              LDR      r0,|L1.556|
0000d0  f8500024          LDR      r0,[r0,r4,LSL #2]     ;78
0000d4  fbb7f1f0          UDIV     r1,r7,r0              ;78
0000d8  fb007011          MLS      r0,r0,r1,r7           ;78
0000dc  b108              CBZ      r0,|L1.226|
0000de  1c70              ADDS     r0,r6,#1              ;78
0000e0  b286              UXTH     r6,r0                 ;78
                  |L1.226|
0000e2  484f              LDR      r0,|L1.544|
0000e4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;79
0000e8  1e45              SUBS     r5,r0,#1              ;79
0000ea  e022              B        |L1.306|
                  |L1.236|
0000ec  484d              LDR      r0,|L1.548|
0000ee  f8500024          LDR      r0,[r0,r4,LSL #2]     ;81
0000f2  f8300015          LDRH     r0,[r0,r5,LSL #1]     ;81
0000f6  b920              CBNZ     r0,|L1.258|
0000f8  f1090001          ADD      r0,r9,#1              ;81
0000fc  fa1ff980          UXTH     r9,r0                 ;81
000100  e001              B        |L1.262|
                  |L1.258|
000102  f04f0900          MOV      r9,#0                 ;82
                  |L1.262|
000106  45b1              CMP      r9,r6                 ;83
000108  d112              BNE      |L1.304|
00010a  f04f0800          MOV      r8,#0                 ;85
00010e  e008              B        |L1.290|
                  |L1.272|
000110  4844              LDR      r0,|L1.548|
000112  f8500024          LDR      r0,[r0,r4,LSL #2]     ;87
000116  eb050108          ADD      r1,r5,r8              ;87
00011a  f8206011          STRH     r6,[r0,r1,LSL #1]     ;87
00011e  f1080801          ADD      r8,r8,#1              ;85
                  |L1.290|
000122  45b0              CMP      r8,r6                 ;85
000124  d3f4              BCC      |L1.272|
000126  4841              LDR      r0,|L1.556|
000128  f8500024          LDR      r0,[r0,r4,LSL #2]     ;89
00012c  4368              MULS     r0,r5,r0              ;89
00012e  e7c6              B        |L1.190|
                  |L1.304|
000130  1e6d              SUBS     r5,r5,#1              ;79
                  |L1.306|
000132  2d00              CMP      r5,#0                 ;79
000134  dada              BGE      |L1.236|
000136  f04f30ff          MOV      r0,#0xffffffff        ;92
00013a  e7c0              B        |L1.190|
;;;94     //释放内存(内部调用) 
                          ENDP

                  mem_free PROC
;;;97     //返回值:0,释放成功;1,释放失败;  
;;;98     u8 mem_free(u8 memx,u32 offset)  
00013c  e92d41f0          PUSH     {r4-r8,lr}
;;;99     {  
000140  4604              MOV      r4,r0
000142  460e              MOV      r6,r1
;;;100        int i;  
;;;101        if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
000144  4837              LDR      r0,|L1.548|
000146  3008              ADDS     r0,r0,#8
000148  5d00              LDRB     r0,[r0,r4]
00014a  b938              CBNZ     r0,|L1.348|
;;;102    	{
;;;103    		mallco_dev.init(memx);    
00014c  4835              LDR      r0,|L1.548|
00014e  3810              SUBS     r0,r0,#0x10
000150  6801              LDR      r1,[r0,#0]  ; mallco_dev
000152  4620              MOV      r0,r4
000154  4788              BLX      r1
;;;104            return 1;//未初始化  
000156  2001              MOVS     r0,#1
                  |L1.344|
;;;105        }  
;;;106        if(offset<memsize[memx])//偏移在内存池内. 
;;;107        {  
;;;108            int index=offset/memblksize[memx];			//偏移所在内存块号码  
;;;109            int nmemb=mallco_dev.memmap[memx][index];	//内存块数量
;;;110            for(i=0;i<nmemb;i++)  						//内存块清零
;;;111            {  
;;;112                mallco_dev.memmap[memx][index+i]=0;  
;;;113            }  
;;;114            return 0;  
;;;115        }else return 2;//偏移超区了.  
;;;116    }  
000158  e8bd81f0          POP      {r4-r8,pc}
                  |L1.348|
00015c  4832              LDR      r0,|L1.552|
00015e  f8500024          LDR      r0,[r0,r4,LSL #2]     ;106
000162  42b0              CMP      r0,r6                 ;106
000164  d917              BLS      |L1.406|
000166  4831              LDR      r0,|L1.556|
000168  f8500024          LDR      r0,[r0,r4,LSL #2]     ;108
00016c  fbb6f1f0          UDIV     r1,r6,r0              ;108
000170  482c              LDR      r0,|L1.548|
000172  f8500024          LDR      r0,[r0,r4,LSL #2]     ;109
000176  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;109
00017a  2500              MOVS     r5,#0                 ;110
00017c  e007              B        |L1.398|
                  |L1.382|
00017e  2300              MOVS     r3,#0                 ;112
000180  4828              LDR      r0,|L1.548|
000182  f8500024          LDR      r0,[r0,r4,LSL #2]     ;112
000186  194f              ADDS     r7,r1,r5              ;112
000188  f8203017          STRH     r3,[r0,r7,LSL #1]     ;112
00018c  1c6d              ADDS     r5,r5,#1              ;110
                  |L1.398|
00018e  4295              CMP      r5,r2                 ;110
000190  dbf5              BLT      |L1.382|
000192  2000              MOVS     r0,#0                 ;114
000194  e7e0              B        |L1.344|
                  |L1.406|
000196  2002              MOVS     r0,#2                 ;115
000198  e7de              B        |L1.344|
;;;117    //释放内存(外部调用) 
                          ENDP

                  myfree PROC
;;;119    //ptr:内存首地址 
;;;120    void myfree(u8 memx,void *ptr)  
00019a  b570              PUSH     {r4-r6,lr}
;;;121    {  
00019c  4605              MOV      r5,r0
00019e  460c              MOV      r4,r1
;;;122    	u32 offset;  
;;;123        if(ptr==NULL)return;//地址为0.  
0001a0  b904              CBNZ     r4,|L1.420|
                  |L1.418|
;;;124     	offset=(u32)ptr-(u32)mallco_dev.membase[memx];  
;;;125        mem_free(memx,offset);//释放内存     
;;;126    }  
0001a2  bd70              POP      {r4-r6,pc}
                  |L1.420|
0001a4  481f              LDR      r0,|L1.548|
0001a6  3808              SUBS     r0,r0,#8              ;124
0001a8  f8500025          LDR      r0,[r0,r5,LSL #2]     ;124
0001ac  1a26              SUBS     r6,r4,r0              ;124
0001ae  4631              MOV      r1,r6                 ;125
0001b0  4628              MOV      r0,r5                 ;125
0001b2  f7fffffe          BL       mem_free
0001b6  bf00              NOP      
0001b8  e7f3              B        |L1.418|
;;;127    //分配内存(外部调用)
                          ENDP

                  mymalloc PROC
;;;130    //返回值:分配到的内存首地址.
;;;131    void *mymalloc(u8 memx,u32 size)  
0001ba  b570              PUSH     {r4-r6,lr}
;;;132    {  
0001bc  4604              MOV      r4,r0
0001be  460e              MOV      r6,r1
;;;133        u32 offset;  									      
;;;134    	offset=mem_malloc(memx,size);  	   				   
0001c0  4631              MOV      r1,r6
0001c2  4620              MOV      r0,r4
0001c4  f7fffffe          BL       mem_malloc
0001c8  4605              MOV      r5,r0
;;;135        if(offset==0XFFFFFFFF)return NULL;  
0001ca  1c68              ADDS     r0,r5,#1
0001cc  d100              BNE      |L1.464|
                  |L1.462|
;;;136        else return (void*)((u32)mallco_dev.membase[memx]+offset);  
;;;137    }  
0001ce  bd70              POP      {r4-r6,pc}
                  |L1.464|
0001d0  4814              LDR      r0,|L1.548|
0001d2  3808              SUBS     r0,r0,#8              ;136
0001d4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;136
0001d8  4428              ADD      r0,r0,r5              ;136
0001da  e7f8              B        |L1.462|
;;;138    //重新分配内存(外部调用)
                          ENDP

                  myrealloc PROC
;;;142    //返回值:新分配到的内存首地址.
;;;143    void *myrealloc(u8 memx,void *ptr,u32 size)  
0001dc  e92d41f0          PUSH     {r4-r8,lr}
;;;144    {  
0001e0  4604              MOV      r4,r0
0001e2  460f              MOV      r7,r1
0001e4  4616              MOV      r6,r2
;;;145        u32 offset;  
;;;146        offset=mem_malloc(memx,size);  
0001e6  4631              MOV      r1,r6
0001e8  4620              MOV      r0,r4
0001ea  f7fffffe          BL       mem_malloc
0001ee  4605              MOV      r5,r0
;;;147        if(offset==0XFFFFFFFF)return NULL;     
0001f0  1c68              ADDS     r0,r5,#1
0001f2  d101              BNE      |L1.504|
                  |L1.500|
;;;148        else  
;;;149        {  									   
;;;150    	    mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size);	//拷贝旧内存内容到新内存   
;;;151            myfree(memx,ptr);  											  		//释放旧内存
;;;152            return (void*)((u32)mallco_dev.membase[memx]+offset);  				//返回新内存首地址
;;;153        }  
;;;154    }
0001f4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.504|
0001f8  490a              LDR      r1,|L1.548|
0001fa  3908              SUBS     r1,r1,#8              ;150
0001fc  f8511024          LDR      r1,[r1,r4,LSL #2]     ;150
000200  1948              ADDS     r0,r1,r5              ;150
000202  4632              MOV      r2,r6                 ;150
000204  4639              MOV      r1,r7                 ;150
000206  f7fffffe          BL       mymemcpy
00020a  4639              MOV      r1,r7                 ;151
00020c  4620              MOV      r0,r4                 ;151
00020e  f7fffffe          BL       myfree
000212  4804              LDR      r0,|L1.548|
000214  3808              SUBS     r0,r0,#8              ;152
000216  f8500024          LDR      r0,[r0,r4,LSL #2]     ;152
00021a  4428              ADD      r0,r0,r5              ;152
00021c  e7ea              B        |L1.500|
;;;155    
                          ENDP

00021e  0000              DCW      0x0000
                  |L1.544|
                          DCD      memtblsize
                  |L1.548|
                          DCD      mallco_dev+0x10
                  |L1.552|
                          DCD      memsize
                  |L1.556|
                          DCD      memblksize

                          AREA ||.ARM.__AT_0x68000000||, DATA, NOINIT, ALIGN=2

                  mem2base
                          %        204800

                          AREA ||.ARM.__AT_0x68032000||, DATA, NOINIT, ALIGN=1

                  mem2mapbase
                          %        12800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mem1base
                          %        40960
                  mem1mapbase
                          %        2560

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x00000500
                          DCD      0x00001900
                  memblksize
                          DCD      0x00000020
                          DCD      0x00000020
                  memsize
                          DCD      0x0000a000
                          DCD      0x00032000

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      mem_init
                          DCD      mem_perused
                          DCD      mem1base
                          DCD      mem2base
                          DCD      mem1mapbase
                          DCD      mem2mapbase
000018  00000000          DCB      0x00,0x00,0x00,0x00
