; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jpstm32_delay.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\jpstm32_delay.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\core -I.\devices -I.\app -I.\boot -I.\app\RES\Num -I.\app\RES\Pic -I"D:\Program Files\Keil\ARM\RV31\INC" -I"D:\Program Files\Keil\ARM\CMSIS\Include" -I"D:\Program Files\Keil\ARM\Inc\ST\STM32F10x" --omf_browse=.\obj\jpstm32_delay.crf core\jpstm32_delay.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _delay_init PROC
;;;46      * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
;;;47     void _delay_init(u8 SYSCLK)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;48     {
;;;49     
;;;50     	//如果使用了ucosII
;;;51     #ifdef OS_CRITICAL_METHOD 	
;;;52     	u32 reload;
;;;53     #endif
;;;54     	//SYSTICK使用外部时钟源	 
;;;55     	SysTick->CTRL&=~(1<<2);	
000004  6909              LDR      r1,[r1,#0x10]
000006  f0210104          BIC      r1,r1,#4
00000a  f04f22e0          MOV      r2,#0xe000e000
00000e  6111              STR      r1,[r2,#0x10]
;;;56     	//不论是否使用ucos,fac_us都需要使用
;;;57     	fac_us=SYSCLK/8;		
000010  17c2              ASRS     r2,r0,#31
000012  eb007252          ADD      r2,r0,r2,LSR #29
000016  10d2              ASRS     r2,r2,#3
000018  4b22              LDR      r3,|L1.164|
00001a  701a              STRB     r2,[r3,#0]
;;;58     
;;;59     	//如果使用了ucosII
;;;60     #ifdef OS_CRITICAL_METHOD 	
;;;61     	//每秒钟的计数次数 单位为K	   
;;;62     	reload=SYSCLK/8;		
;;;63     	//根据OS_TICKS_PER_SEC设定溢出时间
;;;64     	//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;65     	reload*=1000000/OS_TICKS_PER_SEC;
;;;66     	//代表ucos可以延时的最少单位	   
;;;67     	fac_ms=1000/OS_TICKS_PER_SEC;
;;;68     	//开启SYSTICK中断
;;;69     	SysTick->CTRL |= 1<<1;
;;;70     	//每1/OS_TICKS_PER_SEC秒中断一次	
;;;71     	SysTick->LOAD=reload; 	
;;;72     	//开启SYSTICK    
;;;73     	SysTick->CTRL |= 1<<0;
;;;74     #else
;;;75     	//非ucos下,代表每个ms需要的systick时钟数   
;;;76     	fac_ms=(u16)fac_us*1000;
00001c  4619              MOV      r1,r3
00001e  7809              LDRB     r1,[r1,#0]  ; fac_us
000020  eb010241          ADD      r2,r1,r1,LSL #1
000024  ebc211c1          RSB      r1,r2,r1,LSL #7
000028  f64f72ff          MOV      r2,#0xffff
00002c  ea0201c1          AND      r1,r2,r1,LSL #3
000030  4a1d              LDR      r2,|L1.168|
000032  8011              STRH     r1,[r2,#0]
;;;77     #endif
;;;78     }								    
000034  4770              BX       lr
;;;79     
                          ENDP

                  _delay_us PROC
;;;163     * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
;;;164    void _delay_us(u32 nus)
000036  4601              MOV      r1,r0
;;;165    {		
;;;166    	u32 temp;	    	 
;;;167    	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000038  4a1a              LDR      r2,|L1.164|
00003a  7812              LDRB     r2,[r2,#0]  ; fac_us
00003c  434a              MULS     r2,r1,r2
00003e  f04f23e0          MOV      r3,#0xe000e000
000042  615a              STR      r2,[r3,#0x14]
;;;168    	SysTick->VAL=0x00;        //清空计数器
000044  2200              MOVS     r2,#0
000046  619a              STR      r2,[r3,#0x18]
;;;169    	SysTick->CTRL=0x01 ;      //开始倒数 	 
000048  2201              MOVS     r2,#1
00004a  611a              STR      r2,[r3,#0x10]
;;;170    	do
00004c  bf00              NOP      
                  |L1.78|
;;;171    	{
;;;172    		temp=SysTick->CTRL;
00004e  f04f22e0          MOV      r2,#0xe000e000
000052  6910              LDR      r0,[r2,#0x10]
;;;173    	} while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000054  f0100f01          TST      r0,#1
000058  d002              BEQ      |L1.96|
00005a  f4103f80          TST      r0,#0x10000
00005e  d0f6              BEQ      |L1.78|
                  |L1.96|
;;;174    	SysTick->CTRL=0x00;       //关闭计数器
000060  2200              MOVS     r2,#0
000062  f04f23e0          MOV      r3,#0xe000e000
000066  611a              STR      r2,[r3,#0x10]
;;;175    	SysTick->VAL =0X00;       //清空计数器	 
000068  619a              STR      r2,[r3,#0x18]
;;;176    }
00006a  4770              BX       lr
;;;177    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                          ENDP

                  _delay_ms PROC
;;;189     * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
;;;190    void _delay_ms(u16 nms)
00006c  4601              MOV      r1,r0
;;;191    {	 		  	  
;;;192    	u32 temp;		   
;;;193    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
00006e  4a0e              LDR      r2,|L1.168|
000070  8812              LDRH     r2,[r2,#0]  ; fac_ms
000072  434a              MULS     r2,r1,r2
000074  f04f23e0          MOV      r3,#0xe000e000
000078  615a              STR      r2,[r3,#0x14]
;;;194    	SysTick->VAL =0x00;           //清空计数器
00007a  2200              MOVS     r2,#0
00007c  619a              STR      r2,[r3,#0x18]
;;;195    	SysTick->CTRL=0x01 ;          //开始倒数  
00007e  2201              MOVS     r2,#1
000080  611a              STR      r2,[r3,#0x10]
;;;196    	do
000082  bf00              NOP      
                  |L1.132|
;;;197    	{
;;;198    		temp=SysTick->CTRL;
000084  f04f22e0          MOV      r2,#0xe000e000
000088  6910              LDR      r0,[r2,#0x10]
;;;199    	} while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
00008a  f0100f01          TST      r0,#1
00008e  d002              BEQ      |L1.150|
000090  f4103f80          TST      r0,#0x10000
000094  d0f6              BEQ      |L1.132|
                  |L1.150|
;;;200    	SysTick->CTRL=0x00;       //关闭计数器
000096  2200              MOVS     r2,#0
000098  f04f23e0          MOV      r3,#0xe000e000
00009c  611a              STR      r2,[r3,#0x10]
;;;201    	SysTick->VAL =0X00;       //清空计数器	  	    
00009e  619a              STR      r2,[r3,#0x18]
;;;202    } 
0000a0  4770              BX       lr
;;;203    #endif
                          ENDP

0000a2  0000              DCW      0x0000
                  |L1.164|
                          DCD      fac_us
                  |L1.168|
                          DCD      fac_ms

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
